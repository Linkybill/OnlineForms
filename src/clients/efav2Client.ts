//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from "axios";

export class EfaClient {
  protected instance: AxiosInstance;
  protected baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance || axios.create();

    this.baseUrl = baseUrl ?? "/NOVA";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getUsersFromAdGroups(body?: string[] | undefined, cancelToken?: CancelToken): Promise<User[]> {
    let url_ = this.baseUrl + "/api/Ad/GetUsersFromAdGroups";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUsersFromAdGroups(_response);
      });
  }

  protected processGetUsersFromAdGroups(response: AxiosResponse): Promise<User[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(User.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<User[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<User[]>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  getUsersData(body?: UserWithSid[] | undefined, cancelToken?: CancelToken): Promise<User[]> {
    let url_ = this.baseUrl + "/api/Ad/GetUsersData";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUsersData(_response);
      });
  }

  protected processGetUsersData(response: AxiosResponse): Promise<User[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(User.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<User[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<User[]>(null as any);
  }

  /**
   * @param netBiosDomainName (optional)
   * @return Success
   */
  getDnsDomainNameByNetBiosName(netBiosDomainName?: string | undefined, cancelToken?: CancelToken): Promise<string> {
    let url_ = this.baseUrl + "/api/Ad/GetDnsDomainNameByNetBiosName?";
    if (netBiosDomainName === null) throw new Error("The parameter 'netBiosDomainName' cannot be null.");
    else if (netBiosDomainName !== undefined) url_ += "netBiosDomainName=" + encodeURIComponent("" + netBiosDomainName) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDnsDomainNameByNetBiosName(_response);
      });
  }

  protected processGetDnsDomainNameByNetBiosName(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * Gibt alle Active Directory-Gruppen eines Benutzers in der angegebenen Domäne zurück.
   * @param domain (optional) Die Ziel-Domäne (z. B. "mydomain.local").
   * @param username (optional) Der SAM-Accountname des Benutzers (z. B. "max.mustermann").
   * @return Erfolgreich – gibt eine Liste von Gruppennamen zurück.
   */
  getUserGroups(domain?: string | undefined, username?: string | undefined, cancelToken?: CancelToken): Promise<string[]> {
    let url_ = this.baseUrl + "/api/Ad/GetUserGroups?";
    if (domain === null) throw new Error("The parameter 'domain' cannot be null.");
    else if (domain !== undefined) url_ += "domain=" + encodeURIComponent("" + domain) + "&";
    if (username === null) throw new Error("The parameter 'username' cannot be null.");
    else if (username !== undefined) url_ += "username=" + encodeURIComponent("" + username) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUserGroups(_response);
      });
  }

  protected processGetUserGroups(response: AxiosResponse): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(item);
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<string[]>(result200);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("Server Error", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string[]>(null as any);
  }

  /**
   * @param domain (optional)
   * @param body (optional)
   * @return Erfolgreich – gibt eine Liste von Gruppennamen zurück.
   */
  getAdGroupsDescriptions(domain?: string | undefined, body?: string[] | undefined, cancelToken?: CancelToken): Promise<string[]> {
    let url_ = this.baseUrl + "/api/Ad/GetAdGroupsDescriptions?";
    if (domain === null) throw new Error("The parameter 'domain' cannot be null.");
    else if (domain !== undefined) url_ += "domain=" + encodeURIComponent("" + domain) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAdGroupsDescriptions(_response);
      });
  }

  protected processGetAdGroupsDescriptions(response: AxiosResponse): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(item);
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<string[]>(result200);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("Server Error", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string[]>(null as any);
  }

  /**
   * @param siteUrl (optional)
   * @param orgeinheitTermIds (optional)
   * @param pageTitle (optional)
   * @return Success
   */
  getContactPageInfo(siteUrl?: string | undefined, orgeinheitTermIds?: string[] | undefined, pageTitle?: string | undefined, cancelToken?: CancelToken): Promise<ContactPageInfo> {
    let url_ = this.baseUrl + "/api/ContactPages/GetContactPageInfo?";
    if (siteUrl === null) throw new Error("The parameter 'siteUrl' cannot be null.");
    else if (siteUrl !== undefined) url_ += "siteUrl=" + encodeURIComponent("" + siteUrl) + "&";
    if (orgeinheitTermIds === null) throw new Error("The parameter 'orgeinheitTermIds' cannot be null.");
    else if (orgeinheitTermIds !== undefined)
      orgeinheitTermIds &&
        orgeinheitTermIds.forEach((item) => {
          url_ += "orgeinheitTermIds=" + encodeURIComponent("" + item) + "&";
        });
    if (pageTitle === null) throw new Error("The parameter 'pageTitle' cannot be null.");
    else if (pageTitle !== undefined) url_ += "pageTitle=" + encodeURIComponent("" + pageTitle) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetContactPageInfo(_response);
      });
  }

  protected processGetContactPageInfo(response: AxiosResponse): Promise<ContactPageInfo> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ContactPageInfo.fromJS(resultData200);
      return Promise.resolve<ContactPageInfo>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<ContactPageInfo>(null as any);
  }

  /**
   * @param siteUrl (optional)
   * @param userIds (optional)
   * @return Success
   */
  getContactInfo(siteUrl?: string | undefined, userIds?: string[] | undefined, cancelToken?: CancelToken): Promise<Contact[]> {
    let url_ = this.baseUrl + "/api/ContactPages/GetContactInfo?";
    if (siteUrl === null) throw new Error("The parameter 'siteUrl' cannot be null.");
    else if (siteUrl !== undefined) url_ += "siteUrl=" + encodeURIComponent("" + siteUrl) + "&";
    if (userIds === null) throw new Error("The parameter 'userIds' cannot be null.");
    else if (userIds !== undefined)
      userIds &&
        userIds.forEach((item) => {
          url_ += "userIds=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetContactInfo(_response);
      });
  }

  protected processGetContactInfo(response: AxiosResponse): Promise<Contact[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(Contact.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<Contact[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Contact[]>(null as any);
  }

  /**
   * returns an object containing the OrgUnitDescription and the OrganigrammLink
   * @param siteUrl (optional)
   * @param orgeinheitTermId (optional)
   * @return Success
   */
  getOrgUnitInfoByOrgeinheitTermId(siteUrl?: string | undefined, orgeinheitTermId?: string | undefined, cancelToken?: CancelToken): Promise<OrgUnitInfo> {
    let url_ = this.baseUrl + "/api/ContactPages/GetOrgUnitInfoByOrgeinheitTermId?";
    if (siteUrl === null) throw new Error("The parameter 'siteUrl' cannot be null.");
    else if (siteUrl !== undefined) url_ += "siteUrl=" + encodeURIComponent("" + siteUrl) + "&";
    if (orgeinheitTermId === null) throw new Error("The parameter 'orgeinheitTermId' cannot be null.");
    else if (orgeinheitTermId !== undefined) url_ += "orgeinheitTermId=" + encodeURIComponent("" + orgeinheitTermId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetOrgUnitInfoByOrgeinheitTermId(_response);
      });
  }

  protected processGetOrgUnitInfoByOrgeinheitTermId(response: AxiosResponse): Promise<OrgUnitInfo> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = OrgUnitInfo.fromJS(resultData200);
      return Promise.resolve<OrgUnitInfo>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<OrgUnitInfo>(null as any);
  }

  /**
   * returns an object containing the OrgUnitDescription and the OrganigrammLink
   * @param orgUnitId (optional)
   * @return Success
   */
  getOrgUnitInfoByOrgUnitId(orgUnitId?: string | undefined, cancelToken?: CancelToken): Promise<OrgUnitInfo> {
    let url_ = this.baseUrl + "/api/ContactPages/GetOrgUnitInfoByOrgUnitId?";
    if (orgUnitId === null) throw new Error("The parameter 'orgUnitId' cannot be null.");
    else if (orgUnitId !== undefined) url_ += "orgUnitId=" + encodeURIComponent("" + orgUnitId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetOrgUnitInfoByOrgUnitId(_response);
      });
  }

  protected processGetOrgUnitInfoByOrgUnitId(response: AxiosResponse): Promise<OrgUnitInfo> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = OrgUnitInfo.fromJS(resultData200);
      return Promise.resolve<OrgUnitInfo>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<OrgUnitInfo>(null as any);
  }

  /**
     * Sets the field "Recalled" to "true" and the field "FormStatus" to "Das Formular wird zurückgezogen." of the specified form item, if the form was created by the current user
    This causes the workflow to end the configured flow and create an archive copy of the form.
     * @param webUrl (optional) Url of the form website
     * @param listId (optional) Id of the form list
     * @param itemId (optional) List item Id of the form
     * @return Success
     */
  recallForm(webUrl?: string | undefined, listId?: string | undefined, itemId?: number | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/Efa/RecallForm?";
    if (webUrl === null) throw new Error("The parameter 'webUrl' cannot be null.");
    else if (webUrl !== undefined) url_ += "webUrl=" + encodeURIComponent("" + webUrl) + "&";
    if (listId === null) throw new Error("The parameter 'listId' cannot be null.");
    else if (listId !== undefined) url_ += "listId=" + encodeURIComponent("" + listId) + "&";
    if (itemId === null) throw new Error("The parameter 'itemId' cannot be null.");
    else if (itemId !== undefined) url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "PATCH",
      url: url_,
      headers: {},
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRecallForm(_response);
      });
  }

  protected processRecallForm(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * Checks if a form is recalled using direct list item access.
   * @param webUrl (optional) Url of the form website
   * @param listId (optional) Id of the form list
   * @param itemId (optional) List item Id of the form
   * @return Success
   */
  getIsFormRecalled(webUrl?: string | undefined, listId?: string | undefined, itemId?: number | undefined, cancelToken?: CancelToken): Promise<boolean> {
    let url_ = this.baseUrl + "/api/Efa/GetIsFormRecalled?";
    if (webUrl === null) throw new Error("The parameter 'webUrl' cannot be null.");
    else if (webUrl !== undefined) url_ += "webUrl=" + encodeURIComponent("" + webUrl) + "&";
    if (listId === null) throw new Error("The parameter 'listId' cannot be null.");
    else if (listId !== undefined) url_ += "listId=" + encodeURIComponent("" + listId) + "&";
    if (itemId === null) throw new Error("The parameter 'itemId' cannot be null.");
    else if (itemId !== undefined) url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetIsFormRecalled(_response);
      });
  }

  protected processGetIsFormRecalled(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * Checks if a form is recalled using direct list item access.
   * @param webUrl (optional) Url of the form website
   * @param itemId (optional) List item Id of the form
   * @param body (optional) Id of the form list
   * @return Success
   */
  getGraphData(webUrl?: string | undefined, itemId?: number | undefined, body?: { [key: string]: any } | undefined, cancelToken?: CancelToken): Promise<GraphDataResponseDto> {
    let url_ = this.baseUrl + "/api/Efa/GetGraphData?";
    if (webUrl === null) throw new Error("The parameter 'webUrl' cannot be null.");
    else if (webUrl !== undefined) url_ += "webUrl=" + encodeURIComponent("" + webUrl) + "&";
    if (itemId === null) throw new Error("The parameter 'itemId' cannot be null.");
    else if (itemId !== undefined) url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetGraphData(_response);
      });
  }

  protected processGetGraphData(response: AxiosResponse): Promise<GraphDataResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GraphDataResponseDto.fromJS(resultData200);
      return Promise.resolve<GraphDataResponseDto>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<GraphDataResponseDto>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  ankuendigungErstellen(body?: AnkuendigungDto | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/Efa/AnkuendigungErstellen";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAnkuendigungErstellen(_response);
      });
  }

  protected processAnkuendigungErstellen(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  kalenderEintragErstellen(body?: KalenderEintragDto | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/Efa/KalenderEintragErstellen";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processKalenderEintragErstellen(_response);
      });
  }

  protected processKalenderEintragErstellen(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addAndConfigureFormWeb(body?: AddAndConfigureFormWebDto | undefined, cancelToken?: CancelToken): Promise<ConfigureFormWebResponse> {
    let url_ = this.baseUrl + "/api/Efa/AddAndConfigureFormWeb";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddAndConfigureFormWeb(_response);
      });
  }

  protected processAddAndConfigureFormWeb(response: AxiosResponse): Promise<ConfigureFormWebResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ConfigureFormWebResponse.fromJS(resultData200);
      return Promise.resolve<ConfigureFormWebResponse>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<ConfigureFormWebResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  configureExistingFormWebForForm(body?: ConfigureExistingFormWebDto | undefined, cancelToken?: CancelToken): Promise<ConfigureFormWebResponse> {
    let url_ = this.baseUrl + "/api/Efa/ConfigureExistingFormWebForForm";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processConfigureExistingFormWebForForm(_response);
      });
  }

  protected processConfigureExistingFormWebForForm(response: AxiosResponse): Promise<ConfigureFormWebResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ConfigureFormWebResponse.fromJS(resultData200);
      return Promise.resolve<ConfigureFormWebResponse>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<ConfigureFormWebResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  umsetzungITMassnahmeVersenden(body?: UmsetzungITMassnahmeVersendenDto | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/Efa/UmsetzungITMassnahmeVersenden";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUmsetzungITMassnahmeVersenden(_response);
      });
  }

  protected processUmsetzungITMassnahmeVersenden(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  berechtigungsvergabeVersnden(body?: BerechtigungsvergabeVersendenDto | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/Efa/BerechtigungsvergabeVersnden";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processBerechtigungsvergabeVersnden(_response);
      });
  }

  protected processBerechtigungsvergabeVersnden(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  bestellanforderungVersenden(body?: BestellanforderungVersendenDto | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/Efa/BestellanforderungVersenden";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processBestellanforderungVersenden(_response);
      });
  }

  protected processBestellanforderungVersenden(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addFormColumn(body?: AddFormColumnDto | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/Efa/AddFormColumn";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddFormColumn(_response);
      });
  }

  protected processAddFormColumn(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  sendEmailEws(body?: EwsEmail | undefined, cancelToken?: CancelToken): Promise<boolean> {
    let url_ = this.baseUrl + "/api/Efa/SendEmailEws";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSendEmailEws(_response);
      });
  }

  protected processSendEmailEws(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * @param id (optional)
   * @param publicFolderName (optional)
   * @param ewsUrl (optional)
   * @param domainFqdn (optional)
   * @param domain (optional)
   * @return Success
   */
  getPublicFolder(
    id?: string | undefined,
    publicFolderName?: string | undefined,
    ewsUrl?: string | undefined,
    domainFqdn?: string | undefined,
    domain?: string | undefined,
    cancelToken?: CancelToken
  ): Promise<EwsPublicFolder> {
    let url_ = this.baseUrl + "/api/Efa/GetPublicFolder?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += "id=" + encodeURIComponent("" + id) + "&";
    if (publicFolderName === null) throw new Error("The parameter 'publicFolderName' cannot be null.");
    else if (publicFolderName !== undefined) url_ += "publicFolderName=" + encodeURIComponent("" + publicFolderName) + "&";
    if (ewsUrl === null) throw new Error("The parameter 'ewsUrl' cannot be null.");
    else if (ewsUrl !== undefined) url_ += "ewsUrl=" + encodeURIComponent("" + ewsUrl) + "&";
    if (domainFqdn === null) throw new Error("The parameter 'domainFqdn' cannot be null.");
    else if (domainFqdn !== undefined) url_ += "domainFqdn=" + encodeURIComponent("" + domainFqdn) + "&";
    if (domain === null) throw new Error("The parameter 'domain' cannot be null.");
    else if (domain !== undefined) url_ += "domain=" + encodeURIComponent("" + domain) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetPublicFolder(_response);
      });
  }

  protected processGetPublicFolder(response: AxiosResponse): Promise<EwsPublicFolder> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = EwsPublicFolder.fromJS(resultData200);
      return Promise.resolve<EwsPublicFolder>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<EwsPublicFolder>(null as any);
  }

  /**
   * Generate BANF forms
   * @return Success
   */
  createBestellanforderungen(cancelToken?: CancelToken): Promise<number[]> {
    let url_ = this.baseUrl + "/api/Efa/CreateBestellanforderungen";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateBestellanforderungen(_response);
      });
  }

  protected processCreateBestellanforderungen(response: AxiosResponse): Promise<number[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(item);
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<number[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<number[]>(null as any);
  }

  /**
   * Get BANF form data
   * @param body (optional)
   * @return Success
   */
  getBanfFormData(body?: GetBanfFormDataRequestDto | undefined, cancelToken?: CancelToken): Promise<BanfFormData> {
    let url_ = this.baseUrl + "/api/Efa/GetBanfFormData";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetBanfFormData(_response);
      });
  }

  protected processGetBanfFormData(response: AxiosResponse): Promise<BanfFormData> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = BanfFormData.fromJS(resultData200);
      return Promise.resolve<BanfFormData>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<BanfFormData>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  createITMassnahmeForm(body?: CreateITMassnahmeFormDto | undefined, cancelToken?: CancelToken): Promise<number> {
    let url_ = this.baseUrl + "/api/Efa/CreateITMassnahmeForm";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateITMassnahmeForm(_response);
      });
  }

  protected processCreateITMassnahmeForm(response: AxiosResponse): Promise<number> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<number>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<number>(null as any);
  }

  /**
   * Erstellt mehrere Listenelemente in der angegebenen Liste.
   * @param body (optional) Web-URL, Listenname und Listeneinträge.
   * @return Success
   */
  createListItems(body?: CreateListItemsRequestDto | undefined, cancelToken?: CancelToken): Promise<number[]> {
    let url_ = this.baseUrl + "/api/Efa/CreateListItems";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateListItems(_response);
      });
  }

  protected processCreateListItems(response: AxiosResponse): Promise<number[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(item);
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<number[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<number[]>(null as any);
  }

  /**
     * Lädt das Schema (ViewModel) einer SharePoint-Liste anhand von WebUrl und ListName.
    Das Ergebnis ist direkt kompatibel mit dem FieldInfoToFieldDescriptionMapper im Frontend.
     * @param webUrl (optional) URL der SharePoint Site
     * @param listName (optional) Titel der SharePoint-Liste
     * @return Success
     */
  loadListSchema(webUrl?: string | undefined, listName?: string | undefined, cancelToken?: CancelToken): Promise<ListSchemaViewModel> {
    let url_ = this.baseUrl + "/api/Efa/LoadListSchema?";
    if (webUrl === null) throw new Error("The parameter 'webUrl' cannot be null.");
    else if (webUrl !== undefined) url_ += "webUrl=" + encodeURIComponent("" + webUrl) + "&";
    if (listName === null) throw new Error("The parameter 'listName' cannot be null.");
    else if (listName !== undefined) url_ += "listName=" + encodeURIComponent("" + listName) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processLoadListSchema(_response);
      });
  }

  protected processLoadListSchema(response: AxiosResponse): Promise<ListSchemaViewModel> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ListSchemaViewModel.fromJS(resultData200);
      return Promise.resolve<ListSchemaViewModel>(result200);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("Server Error", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<ListSchemaViewModel>(null as any);
  }

  /**
   * @param mandantFilter (optional)
   * @param categoryFilter (optional)
   * @return Success
   */
  getBatchesByMandantAndCategory(mandantFilter?: string | undefined, categoryFilter?: string | undefined, cancelToken?: CancelToken): Promise<Batch[]> {
    let url_ = this.baseUrl + "/api/Efa/GetBatchesByMandantAndCategory?";
    if (mandantFilter === null) throw new Error("The parameter 'mandantFilter' cannot be null.");
    else if (mandantFilter !== undefined) url_ += "mandantFilter=" + encodeURIComponent("" + mandantFilter) + "&";
    if (categoryFilter === null) throw new Error("The parameter 'categoryFilter' cannot be null.");
    else if (categoryFilter !== undefined) url_ += "categoryFilter=" + encodeURIComponent("" + categoryFilter) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetBatchesByMandantAndCategory(_response);
      });
  }

  protected processGetBatchesByMandantAndCategory(response: AxiosResponse): Promise<Batch[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(Batch.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<Batch[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Batch[]>(null as any);
  }

  /**
   * @return Success
   */
  getBatchCategories(cancelToken?: CancelToken): Promise<BatchCategory[]> {
    let url_ = this.baseUrl + "/api/Efa/GetBatchCategories";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetBatchCategories(_response);
      });
  }

  protected processGetBatchCategories(response: AxiosResponse): Promise<BatchCategory[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(BatchCategory.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<BatchCategory[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<BatchCategory[]>(null as any);
  }

  /**
   * @param mandant (optional)
   * @return Success
   */
  getAdminEnvironmentsByMandant(mandant?: string | undefined, cancelToken?: CancelToken): Promise<string[]> {
    let url_ = this.baseUrl + "/api/Efa/GetAdminEnvironmentsByMandant?";
    if (mandant === null) throw new Error("The parameter 'mandant' cannot be null.");
    else if (mandant !== undefined) url_ += "mandant=" + encodeURIComponent("" + mandant) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAdminEnvironmentsByMandant(_response);
      });
  }

  protected processGetAdminEnvironmentsByMandant(response: AxiosResponse): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(item);
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<string[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string[]>(null as any);
  }

  /**
   * @param mandant (optional)
   * @return Success
   */
  getApplicationsEnvironmentsByMandant(mandant?: string | undefined, cancelToken?: CancelToken): Promise<string[]> {
    let url_ = this.baseUrl + "/api/Efa/GetApplicationsEnvironmentsByMandant?";
    if (mandant === null) throw new Error("The parameter 'mandant' cannot be null.");
    else if (mandant !== undefined) url_ += "mandant=" + encodeURIComponent("" + mandant) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetApplicationsEnvironmentsByMandant(_response);
      });
  }

  protected processGetApplicationsEnvironmentsByMandant(response: AxiosResponse): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(item);
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<string[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string[]>(null as any);
  }

  /**
   * @param mandant (optional)
   * @param environment (optional)
   * @return Success
   */
  getAdminRolesByMandantAndEnvironment(mandant?: string | undefined, environment?: string | undefined, cancelToken?: CancelToken): Promise<Role[]> {
    let url_ = this.baseUrl + "/api/Efa/GetAdminRolesByMandantAndEnvironment?";
    if (mandant === null) throw new Error("The parameter 'mandant' cannot be null.");
    else if (mandant !== undefined) url_ += "mandant=" + encodeURIComponent("" + mandant) + "&";
    if (environment === null) throw new Error("The parameter 'environment' cannot be null.");
    else if (environment !== undefined) url_ += "environment=" + encodeURIComponent("" + environment) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAdminRolesByMandantAndEnvironment(_response);
      });
  }

  protected processGetAdminRolesByMandantAndEnvironment(response: AxiosResponse): Promise<Role[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(Role.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<Role[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Role[]>(null as any);
  }

  /**
   * @param mandant (optional)
   * @param environment (optional)
   * @return Success
   */
  getApplicationsCategoriesByMandantAndEnvironment(mandant?: string | undefined, environment?: string | undefined, cancelToken?: CancelToken): Promise<string[]> {
    let url_ = this.baseUrl + "/api/Efa/GetApplicationsCategoriesByMandantAndEnvironment?";
    if (mandant === null) throw new Error("The parameter 'mandant' cannot be null.");
    else if (mandant !== undefined) url_ += "mandant=" + encodeURIComponent("" + mandant) + "&";
    if (environment === null) throw new Error("The parameter 'environment' cannot be null.");
    else if (environment !== undefined) url_ += "environment=" + encodeURIComponent("" + environment) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetApplicationsCategoriesByMandantAndEnvironment(_response);
      });
  }

  protected processGetApplicationsCategoriesByMandantAndEnvironment(response: AxiosResponse): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(item);
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<string[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string[]>(null as any);
  }

  /**
   * @param mandant (optional)
   * @param environment (optional)
   * @param category (optional)
   * @return Success
   */
  getApplicationsRolesByMandantEnvironmentCategory(mandant?: string | undefined, environment?: string | undefined, category?: string | undefined, cancelToken?: CancelToken): Promise<Role[]> {
    let url_ = this.baseUrl + "/api/Efa/GetApplicationsRolesByMandantEnvironmentCategory?";
    if (mandant === null) throw new Error("The parameter 'mandant' cannot be null.");
    else if (mandant !== undefined) url_ += "mandant=" + encodeURIComponent("" + mandant) + "&";
    if (environment === null) throw new Error("The parameter 'environment' cannot be null.");
    else if (environment !== undefined) url_ += "environment=" + encodeURIComponent("" + environment) + "&";
    if (category === null) throw new Error("The parameter 'category' cannot be null.");
    else if (category !== undefined) url_ += "category=" + encodeURIComponent("" + category) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetApplicationsRolesByMandantEnvironmentCategory(_response);
      });
  }

  protected processGetApplicationsRolesByMandantEnvironmentCategory(response: AxiosResponse): Promise<Role[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(Role.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<Role[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Role[]>(null as any);
  }

  /**
   * Executes a search query against Elasticsearch
   * @param body (optional) The search query parameters
   * @return Success
   */
  search(body?: SearchQuery | undefined, cancelToken?: CancelToken): Promise<ElasticSearchResult> {
    let url_ = this.baseUrl + "/api/ElasticSearchService/Search";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSearch(_response);
      });
  }

  protected processSearch(response: AxiosResponse): Promise<ElasticSearchResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ElasticSearchResult.fromJS(resultData200);
      return Promise.resolve<ElasticSearchResult>(result200);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("Server Error", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<ElasticSearchResult>(null as any);
  }

  /**
   * Downloads a document from FileNet
   * @param clientId (optional) Client identifier (needed for Authorization)
   * @param id (optional) Document ID
   * @param objectStore (optional) Object store name
   * @param mimeType (optional) MIME type of the document
   * @return Success
   */
  download(clientId?: string | undefined, id?: string | undefined, objectStore?: string | undefined, mimeType?: string | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/ElasticSearchService/Download?";
    if (clientId === null) throw new Error("The parameter 'clientId' cannot be null.");
    else if (clientId !== undefined) url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined) url_ += "id=" + encodeURIComponent("" + id) + "&";
    if (objectStore === null) throw new Error("The parameter 'objectStore' cannot be null.");
    else if (objectStore !== undefined) url_ += "objectStore=" + encodeURIComponent("" + objectStore) + "&";
    if (mimeType === null) throw new Error("The parameter 'mimeType' cannot be null.");
    else if (mimeType !== undefined) url_ += "mimeType=" + encodeURIComponent("" + mimeType) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {},
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDownload(_response);
      });
  }

  protected processDownload(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 404) {
      const _responseText = response.data;
      return throwException("Not Found", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("Server Error", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * Checks if the current user is member of the Reha group
   * @param clientId (optional) Client identifier (needed for Authorization)
   * @return Success
   */
  checkIfCurrentUserInRehaGroup(clientId?: string | undefined, cancelToken?: CancelToken): Promise<boolean> {
    let url_ = this.baseUrl + "/api/ElasticSearchService/CheckIfCurrentUserInRehaGroup?";
    if (clientId === null) throw new Error("The parameter 'clientId' cannot be null.");
    else if (clientId !== undefined) url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCheckIfCurrentUserInRehaGroup(_response);
      });
  }

  protected processCheckIfCurrentUserInRehaGroup(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * Corrects the Aktenzeichen for a document
   * @param body (optional) The result item with corrected Aktenzeichen
   * @return Success
   */
  aktenzeichenKorrigieren(body?: ElasticSearchResultItem | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/ElasticSearchService/AktenzeichenKorrigieren";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAktenzeichenKorrigieren(_response);
      });
  }

  protected processAktenzeichenKorrigieren(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("Server Error", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param url (optional)
   * @param virtualTimeBudget (optional)
   * @return Success
   */
  convertByUrl(url?: string | undefined, virtualTimeBudget?: number | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/FormToPdf/ConvertByUrl?";
    if (url === null) throw new Error("The parameter 'url' cannot be null.");
    else if (url !== undefined) url_ += "url=" + encodeURIComponent("" + url) + "&";
    if (virtualTimeBudget === null) throw new Error("The parameter 'virtualTimeBudget' cannot be null.");
    else if (virtualTimeBudget !== undefined) url_ += "virtualTimeBudget=" + encodeURIComponent("" + virtualTimeBudget) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {},
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processConvertByUrl(_response);
      });
  }

  protected processConvertByUrl(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param url (optional)
   * @return Success
   */
  printToPdf(url?: string | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/FormToPdf/PrintToPdf?";
    if (url === null) throw new Error("The parameter 'url' cannot be null.");
    else if (url !== undefined) url_ += "url=" + encodeURIComponent("" + url) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {},
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processPrintToPdf(_response);
      });
  }

  protected processPrintToPdf(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  getInventory(cancelToken?: CancelToken): Promise<Inventory> {
    let url_ = this.baseUrl + "/api/HardwareInventory/GetInventory";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetInventory(_response);
      });
  }

  protected processGetInventory(response: AxiosResponse): Promise<Inventory> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = Inventory.fromJS(resultData200);
      return Promise.resolve<Inventory>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Inventory>(null as any);
  }

  /**
   * @param userId (optional)
   * @param inventoryType (optional)
   * @return Success
   */
  getHardwareItems(userId?: string | undefined, inventoryType?: string | undefined, cancelToken?: CancelToken): Promise<Hardware[]> {
    let url_ = this.baseUrl + "/api/HardwareInventory/GetHardwareItems?";
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    if (inventoryType === null) throw new Error("The parameter 'inventoryType' cannot be null.");
    else if (inventoryType !== undefined) url_ += "inventoryType=" + encodeURIComponent("" + inventoryType) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetHardwareItems(_response);
      });
  }

  protected processGetHardwareItems(response: AxiosResponse): Promise<Hardware[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(Hardware.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<Hardware[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Hardware[]>(null as any);
  }

  /**
   * @return Success
   */
  getAusstattungMa(cancelToken?: CancelToken): Promise<Inventory> {
    let url_ = this.baseUrl + "/api/Hardware/GetAusstattungMa";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAusstattungMa(_response);
      });
  }

  protected processGetAusstattungMa(response: AxiosResponse): Promise<Inventory> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = Inventory.fromJS(resultData200);
      return Promise.resolve<Inventory>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Inventory>(null as any);
  }

  /**
   * @return Success
   */
  getAusstattungPool(cancelToken?: CancelToken): Promise<Inventory> {
    let url_ = this.baseUrl + "/api/Hardware/GetAusstattungPool";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAusstattungPool(_response);
      });
  }

  protected processGetAusstattungPool(response: AxiosResponse): Promise<Inventory> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = Inventory.fromJS(resultData200);
      return Promise.resolve<Inventory>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Inventory>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  addHardware(body?: Hardware | undefined, cancelToken?: CancelToken): Promise<string> {
    let url_ = this.baseUrl + "/api/Hardware/AddHardware";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddHardware(_response);
      });
  }

  protected processAddHardware(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * @param userId (optional)
   * @param body (optional)
   * @return Success
   */
  updateHardware(userId?: string | undefined, body?: Hardware | undefined, cancelToken?: CancelToken): Promise<string> {
    let url_ = this.baseUrl + "/api/Hardware/UpdateHardware?";
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateHardware(_response);
      });
  }

  protected processUpdateHardware(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * @param userId (optional)
   * @param body (optional)
   * @return Success
   */
  hardwareExistsChanged(userId?: string | undefined, body?: Hardware | undefined, cancelToken?: CancelToken): Promise<string> {
    let url_ = this.baseUrl + "/api/Hardware/HardwareExistsChanged?";
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processHardwareExistsChanged(_response);
      });
  }

  protected processHardwareExistsChanged(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  deleteHardware(body?: string | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/Hardware/DeleteHardware";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDeleteHardware(_response);
      });
  }

  protected processDeleteHardware(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  completeInventory(cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/Hardware/CompleteInventory";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCompleteInventory(_response);
      });
  }

  protected processCompleteInventory(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  delegatePoolPermissions(body?: string[] | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/HardwareInventory/DelegatePoolPermissions";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDelegatePoolPermissions(_response);
      });
  }

  protected processDelegatePoolPermissions(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  getTickets(cancelToken?: CancelToken): Promise<HelpdeskTicketItem[]> {
    let url_ = this.baseUrl + "/api/HelpdeskTickets/GetTickets";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetTickets(_response);
      });
  }

  protected processGetTickets(response: AxiosResponse): Promise<HelpdeskTicketItem[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(HelpdeskTicketItem.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<HelpdeskTicketItem[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<HelpdeskTicketItem[]>(null as any);
  }

  /**
   * Erstellt ein neues Ticket in Jira.
   * @param body (optional)
   * @return Success
   */
  createTicket(body?: HelpdeskTicketCreationDto | undefined, cancelToken?: CancelToken): Promise<string> {
    let url_ = this.baseUrl + "/api/HelpdeskTickets/CreateTicket";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateTicket(_response);
      });
  }

  protected processCreateTicket(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * @param stoerungsmeldungId (optional)
   * @return Success
   */
  getIncidentDetailsById(stoerungsmeldungId?: string | undefined, cancelToken?: CancelToken): Promise<IncidentDetails> {
    let url_ = this.baseUrl + "/api/IncidentDetails/GetIncidentDetailsById?";
    if (stoerungsmeldungId === null) throw new Error("The parameter 'stoerungsmeldungId' cannot be null.");
    else if (stoerungsmeldungId !== undefined) url_ += "StoerungsmeldungId=" + encodeURIComponent("" + stoerungsmeldungId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetIncidentDetailsById(_response);
      });
  }

  protected processGetIncidentDetailsById(response: AxiosResponse): Promise<IncidentDetails> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = IncidentDetails.fromJS(resultData200);
      return Promise.resolve<IncidentDetails>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<IncidentDetails>(null as any);
  }

  /**
   * @param typ (optional)
   * @param status (optional)
   * @param standort (optional)
   * @return Success
   */
  getInventoryReport(typ?: string | undefined, status?: string | undefined, standort?: string | undefined, cancelToken?: CancelToken): Promise<InventoryReportItem[]> {
    let url_ = this.baseUrl + "/api/InventoryReports/GetInventoryReport?";
    if (typ === null) throw new Error("The parameter 'typ' cannot be null.");
    else if (typ !== undefined) url_ += "typ=" + encodeURIComponent("" + typ) + "&";
    if (status === null) throw new Error("The parameter 'status' cannot be null.");
    else if (status !== undefined) url_ += "status=" + encodeURIComponent("" + status) + "&";
    if (standort === null) throw new Error("The parameter 'standort' cannot be null.");
    else if (standort !== undefined) url_ += "standort=" + encodeURIComponent("" + standort) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetInventoryReport(_response);
      });
  }

  protected processGetInventoryReport(response: AxiosResponse): Promise<InventoryReportItem[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(InventoryReportItem.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<InventoryReportItem[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<InventoryReportItem[]>(null as any);
  }

  /**
   * Erstellt mehrere Listenelemente in der angegebenen Liste.
   * @param body (optional)
   * @return Success
   */
  logInfo(body?: SendLogDto | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/Logging/LogInfo";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processLogInfo(_response);
      });
  }

  protected processLogInfo(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * Erstellt mehrere Listenelemente in der angegebenen Liste.
   * @param body (optional)
   * @return Success
   */
  logError(body?: SendLogDto | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/Logging/LogError";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processLogError(_response);
      });
  }

  protected processLogError(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param correlationId (optional)
   * @return Success
   */
  getLogs(correlationId?: string | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/Logging/GetLogs?";
    if (correlationId === null) throw new Error("The parameter 'correlationId' cannot be null.");
    else if (correlationId !== undefined) url_ += "correlationId=" + encodeURIComponent("" + correlationId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {},
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetLogs(_response);
      });
  }

  protected processGetLogs(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * Gets harware assigned to the user with a value of Austellungsort = "Ausstattung (MA/OE)"
   * @return Success
   */
  getAusstattungMaAll(cancelToken?: CancelToken): Promise<Hardware[]> {
    let url_ = this.baseUrl + "/api/MyHardware/GetAusstattungMa";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAusstattungMaAll(_response);
      });
  }

  protected processGetAusstattungMaAll(response: AxiosResponse): Promise<Hardware[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(Hardware.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<Hardware[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Hardware[]>(null as any);
  }

  /**
   * Gets harware assigned to the user with a value of Austellungsort = "Ausstattung (Pool)"
   * @return Success
   */
  getAusstattungPoolAll(cancelToken?: CancelToken): Promise<Hardware[]> {
    let url_ = this.baseUrl + "/api/MyHardware/GetAusstattungPool";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAusstattungPoolAll(_response);
      });
  }

  protected processGetAusstattungPoolAll(response: AxiosResponse): Promise<Hardware[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(Hardware.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<Hardware[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Hardware[]>(null as any);
  }

  /**
   * Gets service cards (Ausweis) assigned to the user
   * @return Success
   */
  getServiceCards(cancelToken?: CancelToken): Promise<ServiceCard[]> {
    let url_ = this.baseUrl + "/api/MyHardware/GetServiceCards";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetServiceCards(_response);
      });
  }

  protected processGetServiceCards(response: AxiosResponse): Promise<ServiceCard[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(ServiceCard.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<ServiceCard[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<ServiceCard[]>(null as any);
  }

  /**
   * Saves the product in the list of lost items and generates a form for the user to fill out
   * @param body (optional)
   * @return Success
   */
  verlustMelden(body?: Hardware | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/MyHardware/VerlustMelden";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processVerlustMelden(_response);
      });
  }

  protected processVerlustMelden(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  getZusatzSoftware(cancelToken?: CancelToken): Promise<Software[]> {
    let url_ = this.baseUrl + "/api/MySoftware/GetZusatzSoftware";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetZusatzSoftware(_response);
      });
  }

  protected processGetZusatzSoftware(response: AxiosResponse): Promise<Software[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(Software.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<Software[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Software[]>(null as any);
  }

  /**
   * @param adGroupName (optional)
   * @return Success
   */
  getUsersForSoftware(adGroupName?: string | undefined, cancelToken?: CancelToken): Promise<Software> {
    let url_ = this.baseUrl + "/api/MySoftware/GetUsersForSoftware?";
    if (adGroupName === null) throw new Error("The parameter 'adGroupName' cannot be null.");
    else if (adGroupName !== undefined) url_ += "adGroupName=" + encodeURIComponent("" + adGroupName) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUsersForSoftware(_response);
      });
  }

  protected processGetUsersForSoftware(response: AxiosResponse): Promise<Software> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = Software.fromJS(resultData200);
      return Promise.resolve<Software>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Software>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  uninstallSoftware(body?: string | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/MySoftware/UninstallSoftware";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUninstallSoftware(_response);
      });
  }

  protected processUninstallSoftware(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
     * Generates a permissions report for a SharePoint site collection.
    The current user must be a site collection administrator.
     * @param body (optional) The request containing site collection URL and optional destination info.
     * @return Success
     */
  generateReport(body?: GeneratePermissionsReportRequest | undefined, cancelToken?: CancelToken): Promise<GeneratePermissionsReportResponse> {
    let url_ = this.baseUrl + "/api/PermissionsReport/GenerateReport";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGenerateReport(_response);
      });
  }

  protected processGenerateReport(response: AxiosResponse): Promise<GeneratePermissionsReportResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GeneratePermissionsReportResponse.fromJS(resultData200);
      return Promise.resolve<GeneratePermissionsReportResponse>(result200);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<GeneratePermissionsReportResponse>(null as any);
  }

  /**
     * Generates a permissions report for a SharePoint site collection and returns it as an Excel file download.
    The current user must be a site collection administrator.
     * @param siteCollectionUrl (optional) The site collection URL to generate the report for.
     * @return Success
     */
  downloadReport(siteCollectionUrl?: string | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/PermissionsReport/DownloadReport?";
    if (siteCollectionUrl === null) throw new Error("The parameter 'siteCollectionUrl' cannot be null.");
    else if (siteCollectionUrl !== undefined) url_ += "siteCollectionUrl=" + encodeURIComponent("" + siteCollectionUrl) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {},
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDownloadReport(_response);
      });
  }

  protected processDownloadReport(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 401) {
      const _responseText = response.data;
      return throwException("Unauthorized", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * Gets an access token for authentication with SharePoint REST API in extranet.
   * @param clientId (optional) Client id of an provider-hosted application registered in SharePoint.
   * @param siteUrl (optional) Url of a SharePoint site collection.
   * @return Success
   */
  getExtranetAccessToken(clientId?: string | undefined, siteUrl?: string | undefined, cancelToken?: CancelToken): Promise<string> {
    let url_ = this.baseUrl + "/api/S2STrustProvider/GetExtranetAccessToken?";
    if (clientId === null) throw new Error("The parameter 'clientId' cannot be null.");
    else if (clientId !== undefined) url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
    if (siteUrl === null) throw new Error("The parameter 'siteUrl' cannot be null.");
    else if (siteUrl !== undefined) url_ += "siteUrl=" + encodeURIComponent("" + siteUrl) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetExtranetAccessToken(_response);
      });
  }

  protected processGetExtranetAccessToken(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * Gets an "AppOnly" access token for authentication with SharePoint REST API as an App, without user context.
   * @param clientId (optional) Client id of an provider-hosted application registered in SharePoint.
   * @param siteUrl (optional) Url of a SharePoint site collection.
   * @return Success
   */
  getExtranetAppOnlyAccessToken(clientId?: string | undefined, siteUrl?: string | undefined, cancelToken?: CancelToken): Promise<string> {
    let url_ = this.baseUrl + "/api/S2STrustProvider/GetExtranetAppOnlyAccessToken?";
    if (clientId === null) throw new Error("The parameter 'clientId' cannot be null.");
    else if (clientId !== undefined) url_ += "clientId=" + encodeURIComponent("" + clientId) + "&";
    if (siteUrl === null) throw new Error("The parameter 'siteUrl' cannot be null.");
    else if (siteUrl !== undefined) url_ += "siteUrl=" + encodeURIComponent("" + siteUrl) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetExtranetAppOnlyAccessToken(_response);
      });
  }

  protected processGetExtranetAppOnlyAccessToken(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * Gets the user's data
   * @param userId (optional)
   * @return Success
   */
  getUserData(userId?: string | undefined, cancelToken?: CancelToken): Promise<User> {
    let url_ = this.baseUrl + "/api/SapOm/GetUserData?";
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUserData(_response);
      });
  }

  protected processGetUserData(response: AxiosResponse): Promise<User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = User.fromJS(resultData200);
      return Promise.resolve<User>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<User>(null as any);
  }

  /**
   * Gets the user's private address
   * @param userId (optional)
   * @return Success
   */
  getUserPrivateAddress(userId?: string | undefined, cancelToken?: CancelToken): Promise<UserPrivateAddress> {
    let url_ = this.baseUrl + "/api/SapOm/GetUserPrivateAddress?";
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUserPrivateAddress(_response);
      });
  }

  protected processGetUserPrivateAddress(response: AxiosResponse): Promise<UserPrivateAddress> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 204) {
      const _responseText = response.data;
      return throwException("No Content", status, _responseText, _headers);
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = UserPrivateAddress.fromJS(resultData200);
      return Promise.resolve<UserPrivateAddress>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<UserPrivateAddress>(null as any);
  }

  /**
   * Gets the user's max role
   * @param userId (optional)
   * @return Success
   */
  getUserMaxRole(userId?: string | undefined, cancelToken?: CancelToken): Promise<Organisation> {
    let url_ = this.baseUrl + "/api/SapOm/GetUserMaxRole?";
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUserMaxRole(_response);
      });
  }

  protected processGetUserMaxRole(response: AxiosResponse): Promise<Organisation> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = Organisation.fromJS(resultData200);
      return Promise.resolve<Organisation>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Organisation>(null as any);
  }

  /**
   * Checks if the user is a supervisor
   * @param userId (optional)
   * @param level (optional)
   * @return Success
   */
  isSupervisor(userId?: string | undefined, level?: string | undefined, cancelToken?: CancelToken): Promise<boolean> {
    let url_ = this.baseUrl + "/api/SapOm/IsSupervisor?";
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    if (level === null) throw new Error("The parameter 'level' cannot be null.");
    else if (level !== undefined) url_ += "level=" + encodeURIComponent("" + level) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processIsSupervisor(_response);
      });
  }

  protected processIsSupervisor(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * Checks if the user is a supervisor in the future
   * @param userId (optional)
   * @param level (optional)
   * @param referenceDate (optional)
   * @return Success
   */
  isSupervisorUpcoming(userId?: string | undefined, level?: string | undefined, referenceDate?: string | undefined, cancelToken?: CancelToken): Promise<boolean> {
    let url_ = this.baseUrl + "/api/SapOm/IsSupervisorUpcoming?";
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    if (level === null) throw new Error("The parameter 'level' cannot be null.");
    else if (level !== undefined) url_ += "level=" + encodeURIComponent("" + level) + "&";
    if (referenceDate === null) throw new Error("The parameter 'referenceDate' cannot be null.");
    else if (referenceDate !== undefined) url_ += "referenceDate=" + encodeURIComponent("" + referenceDate) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processIsSupervisorUpcoming(_response);
      });
  }

  protected processIsSupervisorUpcoming(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * Checks if the user has an org unit with specific level
   * @param userId (optional)
   * @param level (optional)
   * @return Success
   */
  hasOrgUnitByLevel(userId?: string | undefined, level?: string | undefined, cancelToken?: CancelToken): Promise<boolean> {
    let url_ = this.baseUrl + "/api/SapOm/HasOrgUnitByLevel?";
    if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
    else if (userId !== undefined) url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    if (level === null) throw new Error("The parameter 'level' cannot be null.");
    else if (level !== undefined) url_ += "level=" + encodeURIComponent("" + level) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processHasOrgUnitByLevel(_response);
      });
  }

  protected processHasOrgUnitByLevel(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * Get org units by level and mandant
   * @param level (optional)
   * @param mandant (optional)
   * @return Success
   */
  getOrgUnitsByLevelAndMandant(level?: string | undefined, mandant?: string | undefined, cancelToken?: CancelToken): Promise<Organisation[]> {
    let url_ = this.baseUrl + "/api/SapOm/GetOrgUnitsByLevelAndMandant?";
    if (level === null) throw new Error("The parameter 'level' cannot be null.");
    else if (level !== undefined) url_ += "level=" + encodeURIComponent("" + level) + "&";
    if (mandant === null) throw new Error("The parameter 'mandant' cannot be null.");
    else if (mandant !== undefined) url_ += "mandant=" + encodeURIComponent("" + mandant) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetOrgUnitsByLevelAndMandant(_response);
      });
  }

  protected processGetOrgUnitsByLevelAndMandant(response: AxiosResponse): Promise<Organisation[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(Organisation.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<Organisation[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Organisation[]>(null as any);
  }

  /**
   * @param mandant (optional)
   * @param orgUnitId (optional)
   * @return Success
   */
  getSubOrgunitsByMandantAndOrgunitId(mandant?: string | undefined, orgUnitId?: string | undefined, cancelToken?: CancelToken): Promise<Organisation[]> {
    let url_ = this.baseUrl + "/api/SapOm/GetSubOrgunitsByMandantAndOrgunitId?";
    if (mandant === null) throw new Error("The parameter 'mandant' cannot be null.");
    else if (mandant !== undefined) url_ += "mandant=" + encodeURIComponent("" + mandant) + "&";
    if (orgUnitId === null) throw new Error("The parameter 'orgUnitId' cannot be null.");
    else if (orgUnitId !== undefined) url_ += "orgUnitId=" + encodeURIComponent("" + orgUnitId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetSubOrgunitsByMandantAndOrgunitId(_response);
      });
  }

  protected processGetSubOrgunitsByMandantAndOrgunitId(response: AxiosResponse): Promise<Organisation[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(Organisation.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<Organisation[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Organisation[]>(null as any);
  }

  /**
   * @param orgUnitId (optional)
   * @return Success
   */
  getSupervisorsByOrgUnitId(orgUnitId?: string | undefined, cancelToken?: CancelToken): Promise<User[]> {
    let url_ = this.baseUrl + "/api/SapOm/GetSupervisorsByOrgUnitId?";
    if (orgUnitId === null) throw new Error("The parameter 'orgUnitId' cannot be null.");
    else if (orgUnitId !== undefined) url_ += "orgUnitId=" + encodeURIComponent("" + orgUnitId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetSupervisorsByOrgUnitId(_response);
      });
  }

  protected processGetSupervisorsByOrgUnitId(response: AxiosResponse): Promise<User[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(User.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<User[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<User[]>(null as any);
  }

  /**
   * @param folderTitle (optional)
   * @return Success
   */
  uninstallSoftwareInventory(folderTitle?: string | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/SoftwareInventory/UninstallSoftwareInventory?";
    if (folderTitle === null) throw new Error("The parameter 'folderTitle' cannot be null.");
    else if (folderTitle !== undefined) url_ += "folderTitle=" + encodeURIComponent("" + folderTitle) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUninstallSoftwareInventory(_response);
      });
  }

  protected processUninstallSoftwareInventory(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param folderTitle (optional)
   * @param body (optional)
   * @return Success
   */
  delegatePermissions(folderTitle?: string | undefined, body?: string[] | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/SoftwareInventory/DelegatePermissions?";
    if (folderTitle === null) throw new Error("The parameter 'folderTitle' cannot be null.");
    else if (folderTitle !== undefined) url_ += "folderTitle=" + encodeURIComponent("" + folderTitle) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDelegatePermissions(_response);
      });
  }

  protected processDelegatePermissions(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param queryState (optional)
   * @param selectProperties (optional)
   * @param resultSourceId (optional)
   * @return Success
   */
  exportSearchResults(queryState?: string | undefined, selectProperties?: string | undefined, resultSourceId?: string | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/SpSearchProxy/ExportSearchResults?";
    if (queryState === null) throw new Error("The parameter 'queryState' cannot be null.");
    else if (queryState !== undefined) url_ += "queryState=" + encodeURIComponent("" + queryState) + "&";
    if (selectProperties === null) throw new Error("The parameter 'selectProperties' cannot be null.");
    else if (selectProperties !== undefined) url_ += "selectProperties=" + encodeURIComponent("" + selectProperties) + "&";
    if (resultSourceId === null) throw new Error("The parameter 'resultSourceId' cannot be null.");
    else if (resultSourceId !== undefined) url_ += "resultSourceId=" + encodeURIComponent("" + resultSourceId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {},
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processExportSearchResults(_response);
      });
  }

  protected processExportSearchResults(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @param requestingUserName (optional)
   * @param targetUserEmail (optional)
   * @param forwardToPhoneNumber (optional)
   * @return Success
   */
  setImmediateCallForwarding(requestingUserName?: string | undefined, targetUserEmail?: string | undefined, forwardToPhoneNumber?: string | undefined, cancelToken?: CancelToken): Promise<boolean> {
    let url_ = this.baseUrl + "/api/TeamsCallForwarding/SetImmediateCallForwarding?";
    if (requestingUserName === null) throw new Error("The parameter 'requestingUserName' cannot be null.");
    else if (requestingUserName !== undefined) url_ += "requestingUserName=" + encodeURIComponent("" + requestingUserName) + "&";
    if (targetUserEmail === null) throw new Error("The parameter 'targetUserEmail' cannot be null.");
    else if (targetUserEmail !== undefined) url_ += "targetUserEmail=" + encodeURIComponent("" + targetUserEmail) + "&";
    if (forwardToPhoneNumber === null) throw new Error("The parameter 'forwardToPhoneNumber' cannot be null.");
    else if (forwardToPhoneNumber !== undefined) url_ += "forwardToPhoneNumber=" + encodeURIComponent("" + forwardToPhoneNumber) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSetImmediateCallForwarding(_response);
      });
  }

  protected processSetImmediateCallForwarding(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * @param requestingUserName (optional)
   * @param targetUserEmail (optional)
   * @param forwardToEmail (optional)
   * @return Success
   */
  setImmediateCallForwardingToUser(requestingUserName?: string | undefined, targetUserEmail?: string | undefined, forwardToEmail?: string | undefined, cancelToken?: CancelToken): Promise<boolean> {
    let url_ = this.baseUrl + "/api/TeamsCallForwarding/SetImmediateCallForwardingToUser?";
    if (requestingUserName === null) throw new Error("The parameter 'requestingUserName' cannot be null.");
    else if (requestingUserName !== undefined) url_ += "requestingUserName=" + encodeURIComponent("" + requestingUserName) + "&";
    if (targetUserEmail === null) throw new Error("The parameter 'targetUserEmail' cannot be null.");
    else if (targetUserEmail !== undefined) url_ += "targetUserEmail=" + encodeURIComponent("" + targetUserEmail) + "&";
    if (forwardToEmail === null) throw new Error("The parameter 'forwardToEmail' cannot be null.");
    else if (forwardToEmail !== undefined) url_ += "forwardToEmail=" + encodeURIComponent("" + forwardToEmail) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSetImmediateCallForwardingToUser(_response);
      });
  }

  protected processSetImmediateCallForwardingToUser(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * @param requestingUserName (optional)
   * @param targetUserEmail (optional)
   * @return Success
   */
  disableCallForwarding(requestingUserName?: string | undefined, targetUserEmail?: string | undefined, cancelToken?: CancelToken): Promise<boolean> {
    let url_ = this.baseUrl + "/api/TeamsCallForwarding/DisableCallForwarding?";
    if (requestingUserName === null) throw new Error("The parameter 'requestingUserName' cannot be null.");
    else if (requestingUserName !== undefined) url_ += "requestingUserName=" + encodeURIComponent("" + requestingUserName) + "&";
    if (targetUserEmail === null) throw new Error("The parameter 'targetUserEmail' cannot be null.");
    else if (targetUserEmail !== undefined) url_ += "targetUserEmail=" + encodeURIComponent("" + targetUserEmail) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDisableCallForwarding(_response);
      });
  }

  protected processDisableCallForwarding(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * @param requestingUserName (optional)
   * @param targetUserEmail (optional)
   * @return Success
   */
  isCallForwardingAllowed(requestingUserName?: string | undefined, targetUserEmail?: string | undefined, cancelToken?: CancelToken): Promise<boolean> {
    let url_ = this.baseUrl + "/api/TeamsCallForwarding/IsCallForwardingAllowed?";
    if (requestingUserName === null) throw new Error("The parameter 'requestingUserName' cannot be null.");
    else if (requestingUserName !== undefined) url_ += "requestingUserName=" + encodeURIComponent("" + requestingUserName) + "&";
    if (targetUserEmail === null) throw new Error("The parameter 'targetUserEmail' cannot be null.");
    else if (targetUserEmail !== undefined) url_ += "targetUserEmail=" + encodeURIComponent("" + targetUserEmail) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processIsCallForwardingAllowed(_response);
      });
  }

  protected processIsCallForwardingAllowed(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<boolean>(result200);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
  }

  /**
   * Get presence information for single or multiple users
   * @param body (optional) Array of user names in format Domain\sAmAccountName or email addresses
   * @return Success
   */
  getUserPresence(body?: string[] | undefined, cancelToken?: CancelToken): Promise<{ [key: string]: UserPresenceResult }> {
    let url_ = this.baseUrl + "/api/TeamsCallForwarding/GetUserPresence";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUserPresence(_response);
      });
  }

  protected processGetUserPresence(response: AxiosResponse): Promise<{ [key: string]: UserPresenceResult }> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (resultData200) {
        result200 = {} as any;
        for (let key in resultData200) {
          if (resultData200.hasOwnProperty(key)) (<any>result200)![key] = resultData200[key] ? UserPresenceResult.fromJS(resultData200[key]) : new UserPresenceResult();
        }
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<{ [key: string]: UserPresenceResult }>(result200);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("Bad Request", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<{ [key: string]: UserPresenceResult }>(null as any);
  }

  /**
   * Gets a user photo by user login name.
   * @param userLoginName (optional) The user login name (Personalnummer)
   * @return Success
   */
  getUserPhoto(userLoginName?: string | undefined, cancelToken?: CancelToken): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/UserPhoto/GetUserPhoto?";
    if (userLoginName === null) throw new Error("The parameter 'userLoginName' cannot be null.");
    else if (userLoginName !== undefined) url_ += "userLoginName=" + encodeURIComponent("" + userLoginName) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUserPhoto(_response);
      });
  }

  protected processGetUserPhoto(response: AxiosResponse): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException("Not Found", status, _responseText, _headers, result404);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ProblemDetails.fromJS(resultData400);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = ProblemDetails.fromJS(resultData403);
      return throwException("Forbidden", status, _responseText, _headers, result403);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * Gets user photo metadata by user login name.
   * @param userLoginName (optional) The user login name (Personalnummer)
   * @return Success
   */
  getUserPhotoMetadata(userLoginName?: string | undefined, cancelToken?: CancelToken): Promise<PersonPhotoMetadata> {
    let url_ = this.baseUrl + "/api/UserPhoto/GetUserPhotoMetadata?";
    if (userLoginName === null) throw new Error("The parameter 'userLoginName' cannot be null.");
    else if (userLoginName !== undefined) url_ += "userLoginName=" + encodeURIComponent("" + userLoginName) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUserPhotoMetadata(_response);
      });
  }

  protected processGetUserPhotoMetadata(response: AxiosResponse): Promise<PersonPhotoMetadata> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PersonPhotoMetadata.fromJS(resultData200);
      return Promise.resolve<PersonPhotoMetadata>(result200);
    } else if (status === 404) {
      const _responseText = response.data;
      let result404: any = null;
      let resultData404 = _responseText;
      result404 = ProblemDetails.fromJS(resultData404);
      return throwException("Not Found", status, _responseText, _headers, result404);
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ProblemDetails.fromJS(resultData400);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    } else if (status === 403) {
      const _responseText = response.data;
      let result403: any = null;
      let resultData403 = _responseText;
      result403 = ProblemDetails.fromJS(resultData403);
      return throwException("Forbidden", status, _responseText, _headers, result403);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<PersonPhotoMetadata>(null as any);
  }

  /**
   * Adds a new rating to the survey.
   * @param body (optional) The survey item containing the rating to be added.
   * @return Created
   */
  addRating(body?: SurveyItem | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/api/UserSurvey/AddRating";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddRating(_response);
      });
  }

  protected processAddRating(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 201) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status === 409) {
      const _responseText = response.data;
      return throwException("Conflict", status, _responseText, _headers);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * Gets the ratings for a specific survey item by key.
   * @param key (optional) The key of the survey item.
   * @return Success
   */
  getRatingsByKey(key?: string | undefined, cancelToken?: CancelToken): Promise<SurveyItem> {
    let url_ = this.baseUrl + "/api/UserSurvey/GetRatingsByKey?";
    if (key === null) throw new Error("The parameter 'key' cannot be null.");
    else if (key !== undefined) url_ += "key=" + encodeURIComponent("" + key) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetRatingsByKey(_response);
      });
  }

  protected processGetRatingsByKey(response: AxiosResponse): Promise<SurveyItem> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 204) {
      const _responseText = response.data;
      return throwException("No Content", status, _responseText, _headers);
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = SurveyItem.fromJS(resultData200);
      return Promise.resolve<SurveyItem>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<SurveyItem>(null as any);
  }

  /**
   * Gets all the ratings for all survey items.
   * @return Success
   */
  getAllRatings(cancelToken?: CancelToken): Promise<SurveyItem[]> {
    let url_ = this.baseUrl + "/api/UserSurvey/GetAllRatings";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllRatings(_response);
      });
  }

  protected processGetAllRatings(response: AxiosResponse): Promise<SurveyItem[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 204) {
      const _responseText = response.data;
      return throwException("No Content", status, _responseText, _headers);
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(SurveyItem.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<SurveyItem[]>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<SurveyItem[]>(null as any);
  }

  /**
   * @param method (optional)
   * @param body (optional)
   * @return Success
   */
  search2(method?: string | undefined, body?: string[] | undefined, cancelToken?: CancelToken): Promise<string> {
    let url_ = this.baseUrl + "/api/Zuv/Search?";
    if (method === null) throw new Error("The parameter 'method' cannot be null.");
    else if (method !== undefined) url_ += "method=" + encodeURIComponent("" + method) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json-patch+json",
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSearch2(_response);
      });
  }

  protected processSearch2(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * @param unternehmensnummer (optional)
   * @return Success
   */
  getUnternehmen(unternehmensnummer?: string | undefined, cancelToken?: CancelToken): Promise<string> {
    let url_ = this.baseUrl + "/api/Zuv/GetUnternehmen?";
    if (unternehmensnummer === null) throw new Error("The parameter 'unternehmensnummer' cannot be null.");
    else if (unternehmensnummer !== undefined) url_ += "unternehmensnummer=" + encodeURIComponent("" + unternehmensnummer) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUnternehmen(_response);
      });
  }

  protected processGetUnternehmen(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * @param unternehmernummer (optional)
   * @return Success
   */
  getUnternehmer(unternehmernummer?: string | undefined, cancelToken?: CancelToken): Promise<string> {
    let url_ = this.baseUrl + "/api/Zuv/GetUnternehmer?";
    if (unternehmernummer === null) throw new Error("The parameter 'unternehmernummer' cannot be null.");
    else if (unternehmernummer !== undefined) url_ += "unternehmernummer=" + encodeURIComponent("" + unternehmernummer) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUnternehmer(_response);
      });
  }

  protected processGetUnternehmer(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
  }

  /**
   * @param unternehmensnummer (optional)
   * @param bbnr (optional)
   * @param laufendeNummer (optional)
   * @return Success
   */
  getZustaendigkeit(unternehmensnummer?: string | undefined, bbnr?: string | undefined, laufendeNummer?: string | undefined, cancelToken?: CancelToken): Promise<string> {
    let url_ = this.baseUrl + "/api/Zuv/GetZustaendigkeit?";
    if (unternehmensnummer === null) throw new Error("The parameter 'unternehmensnummer' cannot be null.");
    else if (unternehmensnummer !== undefined) url_ += "unternehmensnummer=" + encodeURIComponent("" + unternehmensnummer) + "&";
    if (bbnr === null) throw new Error("The parameter 'bbnr' cannot be null.");
    else if (bbnr !== undefined) url_ += "bbnr=" + encodeURIComponent("" + bbnr) + "&";
    if (laufendeNummer === null) throw new Error("The parameter 'laufendeNummer' cannot be null.");
    else if (laufendeNummer !== undefined) url_ += "laufendeNummer=" + encodeURIComponent("" + laufendeNummer) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetZustaendigkeit(_response);
      });
  }

  protected processGetZustaendigkeit(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status === 403) {
      const _responseText = response.data;
      return throwException("Forbidden", status, _responseText, _headers);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException("ArgumentException, ArgumentOutOfRangeException, ArgumentNullException", status, _responseText, _headers);
    } else if (status === 500) {
      const _responseText = response.data;
      return throwException("InternalServerError", status, _responseText, _headers);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
  }

  sendMessage(alarmMessage?: AlertMessage | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/hubs/AlertHub/SendMessage?";
    if (alarmMessage === null) throw new Error("The parameter 'alarmMessage' cannot be null.");
    else if (alarmMessage !== undefined) url_ += "alarmMessage=" + encodeURIComponent("" + alarmMessage) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSendMessage(_response);
      });
  }

  protected processSendMessage(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  getAllLocations(cancelToken?: CancelToken): Promise<string[]> {
    let url_ = this.baseUrl + "/hubs/AlertHub/GetAllLocations";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAllLocations(_response);
      });
  }

  protected processGetAllLocations(response: AxiosResponse): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(item);
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<string[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string[]>(null as any);
  }

  /**
   * @return Success
   */
  getDefaultMessages(cancelToken?: CancelToken): Promise<AlertMessage[]> {
    let url_ = this.baseUrl + "/hubs/AlertHub/GetDefaultMessages";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDefaultMessages(_response);
      });
  }

  protected processGetDefaultMessages(response: AxiosResponse): Promise<AlertMessage[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(AlertMessage.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<AlertMessage[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<AlertMessage[]>(null as any);
  }

  /**
   * @return Success
   */
  getAlertMessagesList(cancelToken?: CancelToken): Promise<AlertMessagesList> {
    let url_ = this.baseUrl + "/hubs/AlertHub/GetAlertMessagesList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetAlertMessagesList(_response);
      });
  }

  protected processGetAlertMessagesList(response: AxiosResponse): Promise<AlertMessagesList> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AlertMessagesList.fromJS(resultData200);
      return Promise.resolve<AlertMessagesList>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<AlertMessagesList>(null as any);
  }

  /**
   * @return Success
   */
  getUserLocation(cancelToken?: CancelToken): Promise<string> {
    let url_ = this.baseUrl + "/hubs/AlertHub/GetUserLocation";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUserLocation(_response);
      });
  }

  protected processGetUserLocation(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
  }

  onConnected(cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/hubs/AlertHub/OnConnectedAsync";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processOnConnected(_response);
      });
  }

  protected processOnConnected(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  onDisconnected(exception?: any | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/hubs/AlertHub/OnDisconnectedAsync?";
    if (exception === null) throw new Error("The parameter 'exception' cannot be null.");
    else if (exception !== undefined) url_ += "exception=" + encodeURIComponent("" + exception) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processOnDisconnected(_response);
      });
  }

  protected processOnDisconnected(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  getConnectionId(cancelToken?: CancelToken): Promise<string> {
    let url_ = this.baseUrl + "/hubs/GptResponseHub/GetConnectionId";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetConnectionId(_response);
      });
  }

  protected processGetConnectionId(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = resultData200 !== undefined ? resultData200 : <any>null;

      return Promise.resolve<string>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
  }

  getIncident(incidentMandants?: IncidentMandant[] | undefined, cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/hubs/IncidentHub/GetIncidentAsync?";
    if (incidentMandants === null) throw new Error("The parameter 'incidentMandants' cannot be null.");
    else if (incidentMandants !== undefined)
      incidentMandants &&
        incidentMandants.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ += "incidentMandants[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
            }
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {},
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetIncident(_response);
      });
  }

  protected processGetIncident(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
  }

  /**
   * @return Success
   */
  getStatus(cancelToken?: CancelToken): Promise<IncidentMandant[]> {
    let url_ = this.baseUrl + "/hubs/IncidentHub/GetStatus";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json"
      },
      cancelToken
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetStatus(_response);
      });
  }

  protected processGetStatus(response: AxiosResponse): Promise<IncidentMandant[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(IncidentMandant.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<IncidentMandant[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<IncidentMandant[]>(null as any);
  }
}

export class AddAndConfigureFormWebDto implements IAddAndConfigureFormWebDto {
  /** Url for root web */
  rootWebUrl?: string | undefined;
  /** form title */
  formTitle?: string | undefined;

  constructor(data?: IAddAndConfigureFormWebDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.rootWebUrl = _data["RootWebUrl"];
      this.formTitle = _data["FormTitle"];
    }
  }

  static fromJS(data: any): AddAndConfigureFormWebDto {
    data = typeof data === "object" ? data : {};
    let result = new AddAndConfigureFormWebDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["RootWebUrl"] = this.rootWebUrl;
    data["FormTitle"] = this.formTitle;
    return data;
  }
}

export interface IAddAndConfigureFormWebDto {
  /** Url for root web */
  rootWebUrl?: string | undefined;
  /** form title */
  formTitle?: string | undefined;
}

export class AddFormColumnDto implements IAddFormColumnDto {
  field?: FieldCreationInformation;
  webUrl?: string | undefined;

  constructor(data?: IAddFormColumnDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.field = _data["field"] ? FieldCreationInformation.fromJS(_data["field"]) : <any>undefined;
      this.webUrl = _data["WebUrl"];
    }
  }

  static fromJS(data: any): AddFormColumnDto {
    data = typeof data === "object" ? data : {};
    let result = new AddFormColumnDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["field"] = this.field ? this.field.toJSON() : <any>undefined;
    data["WebUrl"] = this.webUrl;
    return data;
  }
}

export interface IAddFormColumnDto {
  field?: FieldCreationInformation;
  webUrl?: string | undefined;
}

export class AlertMessage implements IAlertMessage {
  id?: number;
  title?: string | undefined;
  user?: string | undefined;
  ip?: string | undefined;
  location?: string | undefined;
  groupName?: string | undefined;
  message?: string | undefined;
  playSound?: boolean;

  constructor(data?: IAlertMessage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["Id"];
      this.title = _data["Title"];
      this.user = _data["User"];
      this.ip = _data["Ip"];
      this.location = _data["Location"];
      this.groupName = _data["GroupName"];
      this.message = _data["Message"];
      this.playSound = _data["PlaySound"];
    }
  }

  static fromJS(data: any): AlertMessage {
    data = typeof data === "object" ? data : {};
    let result = new AlertMessage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["Title"] = this.title;
    data["User"] = this.user;
    data["Ip"] = this.ip;
    data["Location"] = this.location;
    data["GroupName"] = this.groupName;
    data["Message"] = this.message;
    data["PlaySound"] = this.playSound;
    return data;
  }
}

export interface IAlertMessage {
  id?: number;
  title?: string | undefined;
  user?: string | undefined;
  ip?: string | undefined;
  location?: string | undefined;
  groupName?: string | undefined;
  message?: string | undefined;
  playSound?: boolean;
}

export class AlertMessagesList implements IAlertMessagesList {
  title?: string | undefined;
  webUrl?: string | undefined;

  constructor(data?: IAlertMessagesList) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["Title"];
      this.webUrl = _data["WebUrl"];
    }
  }

  static fromJS(data: any): AlertMessagesList {
    data = typeof data === "object" ? data : {};
    let result = new AlertMessagesList();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Title"] = this.title;
    data["WebUrl"] = this.webUrl;
    return data;
  }
}

export interface IAlertMessagesList {
  title?: string | undefined;
  webUrl?: string | undefined;
}

export class AnkuendigungDto implements IAnkuendigungDto {
  webUrl?: string | undefined;
  formName?: string | undefined;
  beschreibung?: string | undefined;
  datumVon?: Date;
  datumBis?: Date;
  begruendung?: string | undefined;
  aktionen?: string[] | undefined;
  kategorien?: string[] | undefined;

  constructor(data?: IAnkuendigungDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.webUrl = _data["WebUrl"];
      this.formName = _data["FormName"];
      this.beschreibung = _data["Beschreibung"];
      this.datumVon = _data["DatumVon"] ? new Date(_data["DatumVon"].toString()) : <any>undefined;
      this.datumBis = _data["DatumBis"] ? new Date(_data["DatumBis"].toString()) : <any>undefined;
      this.begruendung = _data["Begruendung"];
      if (Array.isArray(_data["Aktionen"])) {
        this.aktionen = [] as any;
        for (let item of _data["Aktionen"]) this.aktionen!.push(item);
      }
      if (Array.isArray(_data["Kategorien"])) {
        this.kategorien = [] as any;
        for (let item of _data["Kategorien"]) this.kategorien!.push(item);
      }
    }
  }

  static fromJS(data: any): AnkuendigungDto {
    data = typeof data === "object" ? data : {};
    let result = new AnkuendigungDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["WebUrl"] = this.webUrl;
    data["FormName"] = this.formName;
    data["Beschreibung"] = this.beschreibung;
    data["DatumVon"] = this.datumVon ? this.datumVon.toISOString() : <any>undefined;
    data["DatumBis"] = this.datumBis ? this.datumBis.toISOString() : <any>undefined;
    data["Begruendung"] = this.begruendung;
    if (Array.isArray(this.aktionen)) {
      data["Aktionen"] = [];
      for (let item of this.aktionen) data["Aktionen"].push(item);
    }
    if (Array.isArray(this.kategorien)) {
      data["Kategorien"] = [];
      for (let item of this.kategorien) data["Kategorien"].push(item);
    }
    return data;
  }
}

export interface IAnkuendigungDto {
  webUrl?: string | undefined;
  formName?: string | undefined;
  beschreibung?: string | undefined;
  datumVon?: Date;
  datumBis?: Date;
  begruendung?: string | undefined;
  aktionen?: string[] | undefined;
  kategorien?: string[] | undefined;
}

export class BanfFormData implements IBanfFormData {
  readonly formPrevState?: number;
  readonly formAction?: string | undefined;
  readonly formWebUrl?: string | undefined;
  banfFormItems?: BanfFormItem[] | undefined;

  constructor(data?: IBanfFormData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).formPrevState = _data["FormPrevState"];
      (<any>this).formAction = _data["FormAction"];
      (<any>this).formWebUrl = _data["FormWebUrl"];
      if (Array.isArray(_data["BanfFormItems"])) {
        this.banfFormItems = [] as any;
        for (let item of _data["BanfFormItems"]) this.banfFormItems!.push(BanfFormItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): BanfFormData {
    data = typeof data === "object" ? data : {};
    let result = new BanfFormData();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["FormPrevState"] = this.formPrevState;
    data["FormAction"] = this.formAction;
    data["FormWebUrl"] = this.formWebUrl;
    if (Array.isArray(this.banfFormItems)) {
      data["BanfFormItems"] = [];
      for (let item of this.banfFormItems) data["BanfFormItems"].push(item.toJSON());
    }
    return data;
  }
}

export interface IBanfFormData {
  formPrevState?: number;
  formAction?: string | undefined;
  formWebUrl?: string | undefined;
  banfFormItems?: BanfFormItem[] | undefined;
}

export class BanfFormItem implements IBanfFormItem {
  artikelId?: string | undefined;
  readonly iSBN?: string | undefined;
  readonly verfasser?: string | undefined;
  readonly titel?: string | undefined;
  readonly erscheinungsJahr?: string | undefined;
  readonly anzahl?: string | undefined;
  readonly preis?: number;
  readonly gesamtPreis?: number;
  readonly warenkorbVorhanden?: boolean;
  readonly standardNutzungsdauer?: string | undefined;
  readonly alterPsa?: string | undefined;
  readonly produkt?: string | undefined;
  readonly hersteller?: string | undefined;
  readonly produktbezeichnung?: string | undefined;
  readonly farbe?: string | undefined;
  readonly groesse?: string | undefined;
  readonly aDGroup?: string | undefined;
  readonly isAutomatic?: boolean;
  readonly detailinformation?: string | undefined;
  readonly genehmigungErforderlich?: boolean;

  constructor(data?: IBanfFormItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.artikelId = _data["ArtikelId"];
      (<any>this).iSBN = _data["ISBN"];
      (<any>this).verfasser = _data["Verfasser"];
      (<any>this).titel = _data["Titel"];
      (<any>this).erscheinungsJahr = _data["ErscheinungsJahr"];
      (<any>this).anzahl = _data["Anzahl"];
      (<any>this).preis = _data["Preis"];
      (<any>this).gesamtPreis = _data["GesamtPreis"];
      (<any>this).warenkorbVorhanden = _data["WarenkorbVorhanden"];
      (<any>this).standardNutzungsdauer = _data["StandardNutzungsdauer"];
      (<any>this).alterPsa = _data["AlterPsa"];
      (<any>this).produkt = _data["Produkt"];
      (<any>this).hersteller = _data["Hersteller"];
      (<any>this).produktbezeichnung = _data["Produktbezeichnung"];
      (<any>this).farbe = _data["Farbe"];
      (<any>this).groesse = _data["Groesse"];
      (<any>this).aDGroup = _data["ADGroup"];
      (<any>this).isAutomatic = _data["IsAutomatic"];
      (<any>this).detailinformation = _data["Detailinformation"];
      (<any>this).genehmigungErforderlich = _data["GenehmigungErforderlich"];
    }
  }

  static fromJS(data: any): BanfFormItem {
    data = typeof data === "object" ? data : {};
    let result = new BanfFormItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ArtikelId"] = this.artikelId;
    data["ISBN"] = this.iSBN;
    data["Verfasser"] = this.verfasser;
    data["Titel"] = this.titel;
    data["ErscheinungsJahr"] = this.erscheinungsJahr;
    data["Anzahl"] = this.anzahl;
    data["Preis"] = this.preis;
    data["GesamtPreis"] = this.gesamtPreis;
    data["WarenkorbVorhanden"] = this.warenkorbVorhanden;
    data["StandardNutzungsdauer"] = this.standardNutzungsdauer;
    data["AlterPsa"] = this.alterPsa;
    data["Produkt"] = this.produkt;
    data["Hersteller"] = this.hersteller;
    data["Produktbezeichnung"] = this.produktbezeichnung;
    data["Farbe"] = this.farbe;
    data["Groesse"] = this.groesse;
    data["ADGroup"] = this.aDGroup;
    data["IsAutomatic"] = this.isAutomatic;
    data["Detailinformation"] = this.detailinformation;
    data["GenehmigungErforderlich"] = this.genehmigungErforderlich;
    return data;
  }
}

export interface IBanfFormItem {
  artikelId?: string | undefined;
  iSBN?: string | undefined;
  verfasser?: string | undefined;
  titel?: string | undefined;
  erscheinungsJahr?: string | undefined;
  anzahl?: string | undefined;
  preis?: number;
  gesamtPreis?: number;
  warenkorbVorhanden?: boolean;
  standardNutzungsdauer?: string | undefined;
  alterPsa?: string | undefined;
  produkt?: string | undefined;
  hersteller?: string | undefined;
  produktbezeichnung?: string | undefined;
  farbe?: string | undefined;
  groesse?: string | undefined;
  aDGroup?: string | undefined;
  isAutomatic?: boolean;
  detailinformation?: string | undefined;
  genehmigungErforderlich?: boolean;
}

export class Batch implements IBatch {
  iD?: number;
  batchname?: string | undefined;
  category?: string | undefined;
  mandant?: string | undefined;
  batchType?: string | undefined;
  status?: string | undefined;

  constructor(data?: IBatch) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.iD = _data["ID"];
      this.batchname = _data["Batchname"];
      this.category = _data["Category"];
      this.mandant = _data["Mandant"];
      this.batchType = _data["BatchType"];
      this.status = _data["Status"];
    }
  }

  static fromJS(data: any): Batch {
    data = typeof data === "object" ? data : {};
    let result = new Batch();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ID"] = this.iD;
    data["Batchname"] = this.batchname;
    data["Category"] = this.category;
    data["Mandant"] = this.mandant;
    data["BatchType"] = this.batchType;
    data["Status"] = this.status;
    return data;
  }
}

export interface IBatch {
  iD?: number;
  batchname?: string | undefined;
  category?: string | undefined;
  mandant?: string | undefined;
  batchType?: string | undefined;
  status?: string | undefined;
}

export class BatchCategory implements IBatchCategory {
  iD?: number | undefined;
  displayName?: string | undefined;
  key?: string | undefined;
  stelle?: string | undefined;

  constructor(data?: IBatchCategory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.iD = _data["ID"];
      this.displayName = _data["DisplayName"];
      this.key = _data["Key"];
      this.stelle = _data["Stelle"];
    }
  }

  static fromJS(data: any): BatchCategory {
    data = typeof data === "object" ? data : {};
    let result = new BatchCategory();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ID"] = this.iD;
    data["DisplayName"] = this.displayName;
    data["Key"] = this.key;
    data["Stelle"] = this.stelle;
    return data;
  }
}

export interface IBatchCategory {
  iD?: number | undefined;
  displayName?: string | undefined;
  key?: string | undefined;
  stelle?: string | undefined;
}

export class BerechtigungsVergabeDto implements IBerechtigungsVergabeDto {
  mandant?: string | undefined;
  umgebung?: string | undefined;
  kategorie?: string | undefined;
  rolle?: string | undefined;
  zeitraumVon?: Date;
  zeitraumBis?: Date;

  constructor(data?: IBerechtigungsVergabeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.mandant = _data["Mandant"];
      this.umgebung = _data["Umgebung"];
      this.kategorie = _data["Kategorie"];
      this.rolle = _data["Rolle"];
      this.zeitraumVon = _data["ZeitraumVon"] ? new Date(_data["ZeitraumVon"].toString()) : <any>undefined;
      this.zeitraumBis = _data["ZeitraumBis"] ? new Date(_data["ZeitraumBis"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): BerechtigungsVergabeDto {
    data = typeof data === "object" ? data : {};
    let result = new BerechtigungsVergabeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Mandant"] = this.mandant;
    data["Umgebung"] = this.umgebung;
    data["Kategorie"] = this.kategorie;
    data["Rolle"] = this.rolle;
    data["ZeitraumVon"] = this.zeitraumVon ? this.zeitraumVon.toISOString() : <any>undefined;
    data["ZeitraumBis"] = this.zeitraumBis ? this.zeitraumBis.toISOString() : <any>undefined;
    return data;
  }
}

export interface IBerechtigungsVergabeDto {
  mandant?: string | undefined;
  umgebung?: string | undefined;
  kategorie?: string | undefined;
  rolle?: string | undefined;
  zeitraumVon?: Date;
  zeitraumBis?: Date;
}

export class BerechtigungsvergabeVersendenDto implements IBerechtigungsvergabeVersendenDto {
  webUrl?: string | undefined;
  formName?: string | undefined;
  personalNummer?: string | undefined;
  vorname?: string | undefined;
  nachname?: string | undefined;
  userDomain?: string | undefined;
  systemId?: string | undefined;
  userLoginName?: string | undefined;
  anwendungsberechtigungen?: BerechtigungsVergabeDto[] | undefined;

  constructor(data?: IBerechtigungsvergabeVersendenDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.webUrl = _data["WebUrl"];
      this.formName = _data["FormName"];
      this.personalNummer = _data["PersonalNummer"];
      this.vorname = _data["Vorname"];
      this.nachname = _data["Nachname"];
      this.userDomain = _data["UserDomain"];
      this.systemId = _data["SystemId"];
      this.userLoginName = _data["UserLoginName"];
      if (Array.isArray(_data["Anwendungsberechtigungen"])) {
        this.anwendungsberechtigungen = [] as any;
        for (let item of _data["Anwendungsberechtigungen"]) this.anwendungsberechtigungen!.push(BerechtigungsVergabeDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): BerechtigungsvergabeVersendenDto {
    data = typeof data === "object" ? data : {};
    let result = new BerechtigungsvergabeVersendenDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["WebUrl"] = this.webUrl;
    data["FormName"] = this.formName;
    data["PersonalNummer"] = this.personalNummer;
    data["Vorname"] = this.vorname;
    data["Nachname"] = this.nachname;
    data["UserDomain"] = this.userDomain;
    data["SystemId"] = this.systemId;
    data["UserLoginName"] = this.userLoginName;
    if (Array.isArray(this.anwendungsberechtigungen)) {
      data["Anwendungsberechtigungen"] = [];
      for (let item of this.anwendungsberechtigungen) data["Anwendungsberechtigungen"].push(item.toJSON());
    }
    return data;
  }
}

export interface IBerechtigungsvergabeVersendenDto {
  webUrl?: string | undefined;
  formName?: string | undefined;
  personalNummer?: string | undefined;
  vorname?: string | undefined;
  nachname?: string | undefined;
  userDomain?: string | undefined;
  systemId?: string | undefined;
  userLoginName?: string | undefined;
  anwendungsberechtigungen?: BerechtigungsVergabeDto[] | undefined;
}

export class BestellanforderungVersendenDto implements IBestellanforderungVersendenDto {
  webUrl?: string | undefined;
  formName?: string | undefined;
  personalnummer?: string | undefined;
  mandant?: string | undefined;
  userDomain?: string | undefined;
  systemId?: string | undefined;
  userLoginName?: string | undefined;
  bestellungen?: Bestellung[] | undefined;

  constructor(data?: IBestellanforderungVersendenDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.webUrl = _data["WebUrl"];
      this.formName = _data["FormName"];
      this.personalnummer = _data["Personalnummer"];
      this.mandant = _data["Mandant"];
      this.userDomain = _data["UserDomain"];
      this.systemId = _data["SystemId"];
      this.userLoginName = _data["UserLoginName"];
      if (Array.isArray(_data["Bestellungen"])) {
        this.bestellungen = [] as any;
        for (let item of _data["Bestellungen"]) this.bestellungen!.push(Bestellung.fromJS(item));
      }
    }
  }

  static fromJS(data: any): BestellanforderungVersendenDto {
    data = typeof data === "object" ? data : {};
    let result = new BestellanforderungVersendenDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["WebUrl"] = this.webUrl;
    data["FormName"] = this.formName;
    data["Personalnummer"] = this.personalnummer;
    data["Mandant"] = this.mandant;
    data["UserDomain"] = this.userDomain;
    data["SystemId"] = this.systemId;
    data["UserLoginName"] = this.userLoginName;
    if (Array.isArray(this.bestellungen)) {
      data["Bestellungen"] = [];
      for (let item of this.bestellungen) data["Bestellungen"].push(item.toJSON());
    }
    return data;
  }
}

export interface IBestellanforderungVersendenDto {
  webUrl?: string | undefined;
  formName?: string | undefined;
  personalnummer?: string | undefined;
  mandant?: string | undefined;
  userDomain?: string | undefined;
  systemId?: string | undefined;
  userLoginName?: string | undefined;
  bestellungen?: Bestellung[] | undefined;
}

export class Bestellung implements IBestellung {
  produkt?: string | undefined;
  produktbezeichnung?: string | undefined;
  hersteller?: string | undefined;
  automatisiert?: boolean;
  aDGroup?: string | undefined;

  constructor(data?: IBestellung) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.produkt = _data["Produkt"];
      this.produktbezeichnung = _data["Produktbezeichnung"];
      this.hersteller = _data["Hersteller"];
      this.automatisiert = _data["Automatisiert"];
      this.aDGroup = _data["ADGroup"];
    }
  }

  static fromJS(data: any): Bestellung {
    data = typeof data === "object" ? data : {};
    let result = new Bestellung();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Produkt"] = this.produkt;
    data["Produktbezeichnung"] = this.produktbezeichnung;
    data["Hersteller"] = this.hersteller;
    data["Automatisiert"] = this.automatisiert;
    data["ADGroup"] = this.aDGroup;
    return data;
  }
}

export interface IBestellung {
  produkt?: string | undefined;
  produktbezeichnung?: string | undefined;
  hersteller?: string | undefined;
  automatisiert?: boolean;
  aDGroup?: string | undefined;
}

export class ConfigureExistingFormWebDto implements IConfigureExistingFormWebDto {
  /** Url for root web */
  webUrl?: string | undefined;
  /** form title */
  formTitle?: string | undefined;

  constructor(data?: IConfigureExistingFormWebDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.webUrl = _data["webUrl"];
      this.formTitle = _data["FormTitle"];
    }
  }

  static fromJS(data: any): ConfigureExistingFormWebDto {
    data = typeof data === "object" ? data : {};
    let result = new ConfigureExistingFormWebDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["webUrl"] = this.webUrl;
    data["FormTitle"] = this.formTitle;
    return data;
  }
}

export interface IConfigureExistingFormWebDto {
  /** Url for root web */
  webUrl?: string | undefined;
  /** form title */
  formTitle?: string | undefined;
}

/** ConfigureFormWebResponse */
export class ConfigureFormWebResponse implements IConfigureFormWebResponse {
  /** ValidationError */
  validationError?: string | undefined;
  /** createdWebId */
  createdWebId?: string | undefined;

  constructor(data?: IConfigureFormWebResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.validationError = _data["ValidationError"];
      this.createdWebId = _data["CreatedWebId"];
    }
  }

  static fromJS(data: any): ConfigureFormWebResponse {
    data = typeof data === "object" ? data : {};
    let result = new ConfigureFormWebResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ValidationError"] = this.validationError;
    data["CreatedWebId"] = this.createdWebId;
    return data;
  }
}

/** ConfigureFormWebResponse */
export interface IConfigureFormWebResponse {
  /** ValidationError */
  validationError?: string | undefined;
  /** createdWebId */
  createdWebId?: string | undefined;
}

export class Contact implements IContact {
  id?: string | undefined;
  beschreibung?: string | undefined;
  kategorie?: string | undefined;
  accountName?: string | undefined;
  pictureUrl?: string | undefined;
  sipAddress?: string | undefined;
  displayName?: string | undefined;
  workPhone?: string | undefined;
  workPhoneLink?: string | undefined;
  cellPhone?: string | undefined;
  cellPhoneLink?: string | undefined;
  email?: string | undefined;
  standort?: string | undefined;
  bueroLink?: string | undefined;
  officeNumber?: string | undefined;
  department?: string | undefined;
  funktion?: string | undefined;
  userId?: string | undefined;
  diktatzeichen?: string | undefined;
  organisationseinheit?: string | undefined;
  kontaktseite?: string | undefined;
  geschlecht?: string | undefined;
  position?: number;
  personalnummer?: string | undefined;

  constructor(data?: IContact) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["Id"];
      this.beschreibung = _data["Beschreibung"];
      this.kategorie = _data["Kategorie"];
      this.accountName = _data["AccountName"];
      this.pictureUrl = _data["PictureUrl"];
      this.sipAddress = _data["SipAddress"];
      this.displayName = _data["DisplayName"];
      this.workPhone = _data["WorkPhone"];
      this.workPhoneLink = _data["WorkPhoneLink"];
      this.cellPhone = _data["CellPhone"];
      this.cellPhoneLink = _data["CellPhoneLink"];
      this.email = _data["Email"];
      this.standort = _data["Standort"];
      this.bueroLink = _data["BueroLink"];
      this.officeNumber = _data["OfficeNumber"];
      this.department = _data["Department"];
      this.funktion = _data["Funktion"];
      this.userId = _data["UserId"];
      this.diktatzeichen = _data["Diktatzeichen"];
      this.organisationseinheit = _data["Organisationseinheit"];
      this.kontaktseite = _data["Kontaktseite"];
      this.geschlecht = _data["Geschlecht"];
      this.position = _data["Position"];
      this.personalnummer = _data["Personalnummer"];
    }
  }

  static fromJS(data: any): Contact {
    data = typeof data === "object" ? data : {};
    let result = new Contact();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["Beschreibung"] = this.beschreibung;
    data["Kategorie"] = this.kategorie;
    data["AccountName"] = this.accountName;
    data["PictureUrl"] = this.pictureUrl;
    data["SipAddress"] = this.sipAddress;
    data["DisplayName"] = this.displayName;
    data["WorkPhone"] = this.workPhone;
    data["WorkPhoneLink"] = this.workPhoneLink;
    data["CellPhone"] = this.cellPhone;
    data["CellPhoneLink"] = this.cellPhoneLink;
    data["Email"] = this.email;
    data["Standort"] = this.standort;
    data["BueroLink"] = this.bueroLink;
    data["OfficeNumber"] = this.officeNumber;
    data["Department"] = this.department;
    data["Funktion"] = this.funktion;
    data["UserId"] = this.userId;
    data["Diktatzeichen"] = this.diktatzeichen;
    data["Organisationseinheit"] = this.organisationseinheit;
    data["Kontaktseite"] = this.kontaktseite;
    data["Geschlecht"] = this.geschlecht;
    data["Position"] = this.position;
    data["Personalnummer"] = this.personalnummer;
    return data;
  }
}

export interface IContact {
  id?: string | undefined;
  beschreibung?: string | undefined;
  kategorie?: string | undefined;
  accountName?: string | undefined;
  pictureUrl?: string | undefined;
  sipAddress?: string | undefined;
  displayName?: string | undefined;
  workPhone?: string | undefined;
  workPhoneLink?: string | undefined;
  cellPhone?: string | undefined;
  cellPhoneLink?: string | undefined;
  email?: string | undefined;
  standort?: string | undefined;
  bueroLink?: string | undefined;
  officeNumber?: string | undefined;
  department?: string | undefined;
  funktion?: string | undefined;
  userId?: string | undefined;
  diktatzeichen?: string | undefined;
  organisationseinheit?: string | undefined;
  kontaktseite?: string | undefined;
  geschlecht?: string | undefined;
  position?: number;
  personalnummer?: string | undefined;
}

export class ContactGroup implements IContactGroup {
  contacts?: Contact[] | undefined;
  header?: string | undefined;
  category?: string | undefined;
  groupHeadersListItemId?: number;

  constructor(data?: IContactGroup) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["Contacts"])) {
        this.contacts = [] as any;
        for (let item of _data["Contacts"]) this.contacts!.push(Contact.fromJS(item));
      }
      this.header = _data["Header"];
      this.category = _data["Category"];
      this.groupHeadersListItemId = _data["GroupHeadersListItemId"];
    }
  }

  static fromJS(data: any): ContactGroup {
    data = typeof data === "object" ? data : {};
    let result = new ContactGroup();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.contacts)) {
      data["Contacts"] = [];
      for (let item of this.contacts) data["Contacts"].push(item.toJSON());
    }
    data["Header"] = this.header;
    data["Category"] = this.category;
    data["GroupHeadersListItemId"] = this.groupHeadersListItemId;
    return data;
  }
}

export interface IContactGroup {
  contacts?: Contact[] | undefined;
  header?: string | undefined;
  category?: string | undefined;
  groupHeadersListItemId?: number;
}

export class ContactPageInfo implements IContactPageInfo {
  contactGroups?: ContactGroup[] | undefined;
  pageHasOrgeinheit?: boolean;
  orgUnitDescription?: string | undefined;

  constructor(data?: IContactPageInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["ContactGroups"])) {
        this.contactGroups = [] as any;
        for (let item of _data["ContactGroups"]) this.contactGroups!.push(ContactGroup.fromJS(item));
      }
      this.pageHasOrgeinheit = _data["PageHasOrgeinheit"];
      this.orgUnitDescription = _data["OrgUnitDescription"];
    }
  }

  static fromJS(data: any): ContactPageInfo {
    data = typeof data === "object" ? data : {};
    let result = new ContactPageInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.contactGroups)) {
      data["ContactGroups"] = [];
      for (let item of this.contactGroups) data["ContactGroups"].push(item.toJSON());
    }
    data["PageHasOrgeinheit"] = this.pageHasOrgeinheit;
    data["OrgUnitDescription"] = this.orgUnitDescription;
    return data;
  }
}

export interface IContactPageInfo {
  contactGroups?: ContactGroup[] | undefined;
  pageHasOrgeinheit?: boolean;
  orgUnitDescription?: string | undefined;
}

export class CreateITMassnahmeFormDto implements ICreateITMassnahmeFormDto {
  description?: string | undefined;
  reason?: string | undefined;
  startDate?: Date;
  endDate?: Date;
  neededActions?: string[] | undefined;
  categories?: string[] | undefined;
  effectedApplications?: string[] | undefined;

  constructor(data?: ICreateITMassnahmeFormDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data["Description"];
      this.reason = _data["Reason"];
      this.startDate = _data["StartDate"] ? new Date(_data["StartDate"].toString()) : <any>undefined;
      this.endDate = _data["EndDate"] ? new Date(_data["EndDate"].toString()) : <any>undefined;
      if (Array.isArray(_data["NeededActions"])) {
        this.neededActions = [] as any;
        for (let item of _data["NeededActions"]) this.neededActions!.push(item);
      }
      if (Array.isArray(_data["Categories"])) {
        this.categories = [] as any;
        for (let item of _data["Categories"]) this.categories!.push(item);
      }
      if (Array.isArray(_data["EffectedApplications"])) {
        this.effectedApplications = [] as any;
        for (let item of _data["EffectedApplications"]) this.effectedApplications!.push(item);
      }
    }
  }

  static fromJS(data: any): CreateITMassnahmeFormDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateITMassnahmeFormDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Description"] = this.description;
    data["Reason"] = this.reason;
    data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    if (Array.isArray(this.neededActions)) {
      data["NeededActions"] = [];
      for (let item of this.neededActions) data["NeededActions"].push(item);
    }
    if (Array.isArray(this.categories)) {
      data["Categories"] = [];
      for (let item of this.categories) data["Categories"].push(item);
    }
    if (Array.isArray(this.effectedApplications)) {
      data["EffectedApplications"] = [];
      for (let item of this.effectedApplications) data["EffectedApplications"].push(item);
    }
    return data;
  }
}

export interface ICreateITMassnahmeFormDto {
  description?: string | undefined;
  reason?: string | undefined;
  startDate?: Date;
  endDate?: Date;
  neededActions?: string[] | undefined;
  categories?: string[] | undefined;
  effectedApplications?: string[] | undefined;
}

export class CreateListItemsRequestDto implements ICreateListItemsRequestDto {
  webUrl?: string | undefined;
  listTitle?: string | undefined;
  /** Liste von Dictionarys, wobei jedes Dictionary einem Listenelement entspricht */
  items?: { [key: string]: any }[] | undefined;

  constructor(data?: ICreateListItemsRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.webUrl = _data["WebUrl"];
      this.listTitle = _data["ListTitle"];
      if (Array.isArray(_data["Items"])) {
        this.items = [] as any;
        for (let item of _data["Items"]) this.items!.push(item);
      }
    }
  }

  static fromJS(data: any): CreateListItemsRequestDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateListItemsRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["WebUrl"] = this.webUrl;
    data["ListTitle"] = this.listTitle;
    if (Array.isArray(this.items)) {
      data["Items"] = [];
      for (let item of this.items) data["Items"].push(item);
    }
    return data;
  }
}

export interface ICreateListItemsRequestDto {
  webUrl?: string | undefined;
  listTitle?: string | undefined;
  /** Liste von Dictionarys, wobei jedes Dictionary einem Listenelement entspricht */
  items?: { [key: string]: any }[] | undefined;
}

/** Elasticsearch search result */
export class ElasticSearchResult implements IElasticSearchResult {
  /** Total number of results */
  totalResults?: number;
  /** Results for current page */
  pageResults?: ElasticSearchResultItem[] | undefined;

  constructor(data?: IElasticSearchResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalResults = _data["TotalResults"];
      if (Array.isArray(_data["PageResults"])) {
        this.pageResults = [] as any;
        for (let item of _data["PageResults"]) this.pageResults!.push(ElasticSearchResultItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ElasticSearchResult {
    data = typeof data === "object" ? data : {};
    let result = new ElasticSearchResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["TotalResults"] = this.totalResults;
    if (Array.isArray(this.pageResults)) {
      data["PageResults"] = [];
      for (let item of this.pageResults) data["PageResults"].push(item.toJSON());
    }
    return data;
  }
}

/** Elasticsearch search result */
export interface IElasticSearchResult {
  /** Total number of results */
  totalResults?: number;
  /** Results for current page */
  pageResults?: ElasticSearchResultItem[] | undefined;
}

/** Individual search result item */
export class ElasticSearchResultItem implements IElasticSearchResultItem {
  /** Document ID */
  id?: string | undefined;
  /** MIME type */
  mimeType?: string | undefined;
  /** File extension */
  fileExt?: string | undefined;
  /** Indicates if item has been modified */
  isModified?: boolean;
  /** Cell values */
  cells?: ElasticSearchResultItemCell[] | undefined;

  constructor(data?: IElasticSearchResultItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["Id"];
      this.mimeType = _data["MimeType"];
      this.fileExt = _data["FileExt"];
      this.isModified = _data["IsModified"];
      if (Array.isArray(_data["Cells"])) {
        this.cells = [] as any;
        for (let item of _data["Cells"]) this.cells!.push(ElasticSearchResultItemCell.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ElasticSearchResultItem {
    data = typeof data === "object" ? data : {};
    let result = new ElasticSearchResultItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["MimeType"] = this.mimeType;
    data["FileExt"] = this.fileExt;
    data["IsModified"] = this.isModified;
    if (Array.isArray(this.cells)) {
      data["Cells"] = [];
      for (let item of this.cells) data["Cells"].push(item.toJSON());
    }
    return data;
  }
}

/** Individual search result item */
export interface IElasticSearchResultItem {
  /** Document ID */
  id?: string | undefined;
  /** MIME type */
  mimeType?: string | undefined;
  /** File extension */
  fileExt?: string | undefined;
  /** Indicates if item has been modified */
  isModified?: boolean;
  /** Cell values */
  cells?: ElasticSearchResultItemCell[] | undefined;
}

/** Individual cell in search result */
export class ElasticSearchResultItemCell implements IElasticSearchResultItemCell {
  /** Symbolic name of the property */
  symbolicName?: string | undefined;
  /** Value of the cell */
  value?: any | undefined;
  /** Data type */
  type?: string | undefined;

  constructor(data?: IElasticSearchResultItemCell) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.symbolicName = _data["SymbolicName"];
      this.value = _data["Value"];
      this.type = _data["Type"];
    }
  }

  static fromJS(data: any): ElasticSearchResultItemCell {
    data = typeof data === "object" ? data : {};
    let result = new ElasticSearchResultItemCell();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["SymbolicName"] = this.symbolicName;
    data["Value"] = this.value;
    data["Type"] = this.type;
    return data;
  }
}

/** Individual cell in search result */
export interface IElasticSearchResultItemCell {
  /** Symbolic name of the property */
  symbolicName?: string | undefined;
  /** Value of the cell */
  value?: any | undefined;
  /** Data type */
  type?: string | undefined;
}

export class EwsEmail implements IEwsEmail {
  ewsUrl?: string | undefined;
  to?: string | undefined;
  subject?: string | undefined;
  body?: string | undefined;

  constructor(data?: IEwsEmail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ewsUrl = _data["EwsUrl"];
      this.to = _data["To"];
      this.subject = _data["Subject"];
      this.body = _data["Body"];
    }
  }

  static fromJS(data: any): EwsEmail {
    data = typeof data === "object" ? data : {};
    let result = new EwsEmail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["EwsUrl"] = this.ewsUrl;
    data["To"] = this.to;
    data["Subject"] = this.subject;
    data["Body"] = this.body;
    return data;
  }
}

export interface IEwsEmail {
  ewsUrl?: string | undefined;
  to?: string | undefined;
  subject?: string | undefined;
  body?: string | undefined;
}

export class EwsPublicFolder implements IEwsPublicFolder {
  id?: string | undefined;
  email?: string | undefined;
  members?: string[] | undefined;

  constructor(data?: IEwsPublicFolder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["Id"];
      this.email = _data["Email"];
      if (Array.isArray(_data["Members"])) {
        this.members = [] as any;
        for (let item of _data["Members"]) this.members!.push(item);
      }
    }
  }

  static fromJS(data: any): EwsPublicFolder {
    data = typeof data === "object" ? data : {};
    let result = new EwsPublicFolder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["Email"] = this.email;
    if (Array.isArray(this.members)) {
      data["Members"] = [];
      for (let item of this.members) data["Members"].push(item);
    }
    return data;
  }
}

export interface IEwsPublicFolder {
  id?: string | undefined;
  email?: string | undefined;
  members?: string[] | undefined;
}

export class FieldCreationInformation implements IFieldCreationInformation {
  id?: string;
  displayName?: string | undefined;
  internalName?: string | undefined;
  fieldType?: FieldType;
  group?: string | undefined;
  required?: boolean;
  requiredString?: string | undefined;
  fillInChoice?: boolean;
  fillInChoiceString?: string | undefined;
  sourceID?: string | undefined;
  staticName?: string | undefined;
  colName?: string | undefined;
  rowOrdinal?: number;
  version?: number;
  customFormatter?: string | undefined;
  enforceUniqueValues?: boolean;
  enforceUniqueValuesString?: string | undefined;
  indexed?: boolean;
  indexedString?: string | undefined;
  format?: string | undefined;
  choices?: string[] | undefined;

  constructor(data?: IFieldCreationInformation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["Id"];
      this.displayName = _data["DisplayName"];
      this.internalName = _data["InternalName"];
      this.fieldType = _data["FieldType"];
      this.group = _data["Group"];
      this.required = _data["Required"];
      this.requiredString = _data["RequiredString"];
      this.fillInChoice = _data["FillInChoice"];
      this.fillInChoiceString = _data["FillInChoiceString"];
      this.sourceID = _data["SourceID"];
      this.staticName = _data["StaticName"];
      this.colName = _data["ColName"];
      this.rowOrdinal = _data["RowOrdinal"];
      this.version = _data["Version"];
      this.customFormatter = _data["CustomFormatter"];
      this.enforceUniqueValues = _data["EnforceUniqueValues"];
      this.enforceUniqueValuesString = _data["EnforceUniqueValuesString"];
      this.indexed = _data["Indexed"];
      this.indexedString = _data["IndexedString"];
      this.format = _data["Format"];
      if (Array.isArray(_data["Choices"])) {
        this.choices = [] as any;
        for (let item of _data["Choices"]) this.choices!.push(item);
      }
    }
  }

  static fromJS(data: any): FieldCreationInformation {
    data = typeof data === "object" ? data : {};
    let result = new FieldCreationInformation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["DisplayName"] = this.displayName;
    data["InternalName"] = this.internalName;
    data["FieldType"] = this.fieldType;
    data["Group"] = this.group;
    data["Required"] = this.required;
    data["RequiredString"] = this.requiredString;
    data["FillInChoice"] = this.fillInChoice;
    data["FillInChoiceString"] = this.fillInChoiceString;
    data["SourceID"] = this.sourceID;
    data["StaticName"] = this.staticName;
    data["ColName"] = this.colName;
    data["RowOrdinal"] = this.rowOrdinal;
    data["Version"] = this.version;
    data["CustomFormatter"] = this.customFormatter;
    data["EnforceUniqueValues"] = this.enforceUniqueValues;
    data["EnforceUniqueValuesString"] = this.enforceUniqueValuesString;
    data["Indexed"] = this.indexed;
    data["IndexedString"] = this.indexedString;
    data["Format"] = this.format;
    if (Array.isArray(this.choices)) {
      data["Choices"] = [];
      for (let item of this.choices) data["Choices"].push(item);
    }
    return data;
  }
}

export interface IFieldCreationInformation {
  id?: string;
  displayName?: string | undefined;
  internalName?: string | undefined;
  fieldType?: FieldType;
  group?: string | undefined;
  required?: boolean;
  requiredString?: string | undefined;
  fillInChoice?: boolean;
  fillInChoiceString?: string | undefined;
  sourceID?: string | undefined;
  staticName?: string | undefined;
  colName?: string | undefined;
  rowOrdinal?: number;
  version?: number;
  customFormatter?: string | undefined;
  enforceUniqueValues?: boolean;
  enforceUniqueValuesString?: string | undefined;
  indexed?: boolean;
  indexedString?: string | undefined;
  format?: string | undefined;
  choices?: string[] | undefined;
}

export class FieldInfoViewModel implements IFieldInfoViewModel {
  description?: string | undefined;
  hidden?: boolean;
  id?: string | undefined;
  indexed?: boolean;
  internalName?: string | undefined;
  staticName?: string | undefined;
  title?: string | undefined;
  typeAsString?: string | undefined;
  typeDisplayName?: string | undefined;
  typeShortDescription?: string | undefined;
  readOnlyField?: boolean;
  additionalData?: { [key: string]: JsonElement } | undefined;

  constructor(data?: IFieldInfoViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data["Description"];
      this.hidden = _data["Hidden"];
      this.id = _data["Id"];
      this.indexed = _data["Indexed"];
      this.internalName = _data["InternalName"];
      this.staticName = _data["StaticName"];
      this.title = _data["Title"];
      this.typeAsString = _data["TypeAsString"];
      this.typeDisplayName = _data["TypeDisplayName"];
      this.typeShortDescription = _data["TypeShortDescription"];
      this.readOnlyField = _data["ReadOnlyField"];
      if (_data["AdditionalData"]) {
        this.additionalData = {} as any;
        for (let key in _data["AdditionalData"]) {
          if (_data["AdditionalData"].hasOwnProperty(key)) (<any>this.additionalData)![key] = _data["AdditionalData"][key] ? JsonElement.fromJS(_data["AdditionalData"][key]) : new JsonElement();
        }
      }
    }
  }

  static fromJS(data: any): FieldInfoViewModel {
    data = typeof data === "object" ? data : {};
    let result = new FieldInfoViewModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Description"] = this.description;
    data["Hidden"] = this.hidden;
    data["Id"] = this.id;
    data["Indexed"] = this.indexed;
    data["InternalName"] = this.internalName;
    data["StaticName"] = this.staticName;
    data["Title"] = this.title;
    data["TypeAsString"] = this.typeAsString;
    data["TypeDisplayName"] = this.typeDisplayName;
    data["TypeShortDescription"] = this.typeShortDescription;
    data["ReadOnlyField"] = this.readOnlyField;
    if (this.additionalData) {
      data["AdditionalData"] = {};
      for (let key in this.additionalData) {
        if (this.additionalData.hasOwnProperty(key)) (<any>data["AdditionalData"])[key] = this.additionalData[key] ? this.additionalData[key].toJSON() : <any>undefined;
      }
    }
    return data;
  }
}

export interface IFieldInfoViewModel {
  description?: string | undefined;
  hidden?: boolean;
  id?: string | undefined;
  indexed?: boolean;
  internalName?: string | undefined;
  staticName?: string | undefined;
  title?: string | undefined;
  typeAsString?: string | undefined;
  typeDisplayName?: string | undefined;
  typeShortDescription?: string | undefined;
  readOnlyField?: boolean;
  additionalData?: { [key: string]: JsonElement } | undefined;
}

export enum FieldType {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _3 = 3,
  _4 = 4,
  _5 = 5,
  _6 = 6,
  _7 = 7,
  _8 = 8,
  _9 = 9,
  _10 = 10,
  _11 = 11,
  _12 = 12,
  _13 = 13,
  _14 = 14,
  _15 = 15,
  _16 = 16,
  _17 = 17,
  _18 = 18,
  _19 = 19,
  _20 = 20,
  _21 = 21,
  _22 = 22,
  _23 = 23,
  _24 = 24,
  _25 = 25,
  _26 = 26,
  _27 = 27,
  _28 = 28,
  _29 = 29,
  _30 = 30,
  _31 = 31,
  _32 = 32,
  _33 = 33,
  _34 = 34
}

/** FileNet property definition */
export class FileNetProperty implements IFileNetProperty {
  /** Symbolic name */
  symbolicName?: string | undefined;
  /** Display name */
  displayName?: string | undefined;
  /** Label for UI */
  label?: string | undefined;
  /** Whether the property is sortable */
  isSortable?: boolean;
  /** Whether the property can have multiple values */
  isMultiValue?: boolean;
  /** Data type (text, int, date, guid, etc.) */
  type?: string | undefined;
  /** Comparison operator (equal, not-equal, contain, etc.) */
  operator?: string | undefined;
  /** Value for filtering */
  value?: any | undefined;
  /** XPath for XML template */
  xmlXpath?: string | undefined;

  constructor(data?: IFileNetProperty) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.symbolicName = _data["SymbolicName"];
      this.displayName = _data["DisplayName"];
      this.label = _data["Label"];
      this.isSortable = _data["IsSortable"];
      this.isMultiValue = _data["IsMultiValue"];
      this.type = _data["Type"];
      this.operator = _data["Operator"];
      this.value = _data["Value"];
      this.xmlXpath = _data["XmlXpath"];
    }
  }

  static fromJS(data: any): FileNetProperty {
    data = typeof data === "object" ? data : {};
    let result = new FileNetProperty();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["SymbolicName"] = this.symbolicName;
    data["DisplayName"] = this.displayName;
    data["Label"] = this.label;
    data["IsSortable"] = this.isSortable;
    data["IsMultiValue"] = this.isMultiValue;
    data["Type"] = this.type;
    data["Operator"] = this.operator;
    data["Value"] = this.value;
    data["XmlXpath"] = this.xmlXpath;
    return data;
  }
}

/** FileNet property definition */
export interface IFileNetProperty {
  /** Symbolic name */
  symbolicName?: string | undefined;
  /** Display name */
  displayName?: string | undefined;
  /** Label for UI */
  label?: string | undefined;
  /** Whether the property is sortable */
  isSortable?: boolean;
  /** Whether the property can have multiple values */
  isMultiValue?: boolean;
  /** Data type (text, int, date, guid, etc.) */
  type?: string | undefined;
  /** Comparison operator (equal, not-equal, contain, etc.) */
  operator?: string | undefined;
  /** Value for filtering */
  value?: any | undefined;
  /** XPath for XML template */
  xmlXpath?: string | undefined;
}

/** Request DTO for generating a permissions report. */
export class GeneratePermissionsReportRequest implements IGeneratePermissionsReportRequest {
  /** The site collection URL to generate the report for. */
  siteCollectionUrl!: string;
  /** The server-relative URL of the folder where the report file should be uploaded.
Must be within the same site collection. */
  destinationFolderServerRelativeUrl?: string | undefined;
  /** The name of the report file (without extension). If not provided, a default name with timestamp will be used. */
  reportFileName?: string | undefined;

  constructor(data?: IGeneratePermissionsReportRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.siteCollectionUrl = _data["SiteCollectionUrl"];
      this.destinationFolderServerRelativeUrl = _data["DestinationFolderServerRelativeUrl"];
      this.reportFileName = _data["ReportFileName"];
    }
  }

  static fromJS(data: any): GeneratePermissionsReportRequest {
    data = typeof data === "object" ? data : {};
    let result = new GeneratePermissionsReportRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["SiteCollectionUrl"] = this.siteCollectionUrl;
    data["DestinationFolderServerRelativeUrl"] = this.destinationFolderServerRelativeUrl;
    data["ReportFileName"] = this.reportFileName;
    return data;
  }
}

/** Request DTO for generating a permissions report. */
export interface IGeneratePermissionsReportRequest {
  /** The site collection URL to generate the report for. */
  siteCollectionUrl: string;
  /** The server-relative URL of the folder where the report file should be uploaded.
Must be within the same site collection. */
  destinationFolderServerRelativeUrl?: string | undefined;
  /** The name of the report file (without extension). If not provided, a default name with timestamp will be used. */
  reportFileName?: string | undefined;
}

/** Response DTO containing the result of the permissions report generation. */
export class GeneratePermissionsReportResponse implements IGeneratePermissionsReportResponse {
  /** The URL where the report file was uploaded (if uploaded to SharePoint). */
  reportFileUrl?: string | undefined;
  /** The file name of the generated report. */
  fileName?: string | undefined;
  /** Number of permission entries in the report. */
  permissionCount?: number;
  /** Indicates whether the report was uploaded to SharePoint. */
  uploadedToSharePoint?: boolean;

  constructor(data?: IGeneratePermissionsReportResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.reportFileUrl = _data["ReportFileUrl"];
      this.fileName = _data["FileName"];
      this.permissionCount = _data["PermissionCount"];
      this.uploadedToSharePoint = _data["UploadedToSharePoint"];
    }
  }

  static fromJS(data: any): GeneratePermissionsReportResponse {
    data = typeof data === "object" ? data : {};
    let result = new GeneratePermissionsReportResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ReportFileUrl"] = this.reportFileUrl;
    data["FileName"] = this.fileName;
    data["PermissionCount"] = this.permissionCount;
    data["UploadedToSharePoint"] = this.uploadedToSharePoint;
    return data;
  }
}

/** Response DTO containing the result of the permissions report generation. */
export interface IGeneratePermissionsReportResponse {
  /** The URL where the report file was uploaded (if uploaded to SharePoint). */
  reportFileUrl?: string | undefined;
  /** The file name of the generated report. */
  fileName?: string | undefined;
  /** Number of permission entries in the report. */
  permissionCount?: number;
  /** Indicates whether the report was uploaded to SharePoint. */
  uploadedToSharePoint?: boolean;
}

export class GetBanfFormDataRequestDto implements IGetBanfFormDataRequestDto {
  warenkorbItemIds?: number[] | undefined;

  constructor(data?: IGetBanfFormDataRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["WarenkorbItemIds"])) {
        this.warenkorbItemIds = [] as any;
        for (let item of _data["WarenkorbItemIds"]) this.warenkorbItemIds!.push(item);
      }
    }
  }

  static fromJS(data: any): GetBanfFormDataRequestDto {
    data = typeof data === "object" ? data : {};
    let result = new GetBanfFormDataRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.warenkorbItemIds)) {
      data["WarenkorbItemIds"] = [];
      for (let item of this.warenkorbItemIds) data["WarenkorbItemIds"].push(item);
    }
    return data;
  }
}

export interface IGetBanfFormDataRequestDto {
  warenkorbItemIds?: number[] | undefined;
}

export class GraphDataResponseDto implements IGraphDataResponseDto {
  /** Nodes */
  graphNodes?: GraphNode[] | undefined;

  constructor(data?: IGraphDataResponseDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["GraphNodes"])) {
        this.graphNodes = [] as any;
        for (let item of _data["GraphNodes"]) this.graphNodes!.push(GraphNode.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GraphDataResponseDto {
    data = typeof data === "object" ? data : {};
    let result = new GraphDataResponseDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.graphNodes)) {
      data["GraphNodes"] = [];
      for (let item of this.graphNodes) data["GraphNodes"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGraphDataResponseDto {
  /** Nodes */
  graphNodes?: GraphNode[] | undefined;
}

export class GraphNode implements IGraphNode {
  /** Title */
  title?: string | undefined;
  /** Text */
  text?: string | undefined;
  /** IsCurrent */
  isCurrent?: boolean;
  /** Id */
  id?: string | undefined;

  constructor(data?: IGraphNode) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["Title"];
      this.text = _data["Text"];
      this.isCurrent = _data["IsCurrent"];
      this.id = _data["Id"];
    }
  }

  static fromJS(data: any): GraphNode {
    data = typeof data === "object" ? data : {};
    let result = new GraphNode();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Title"] = this.title;
    data["Text"] = this.text;
    data["IsCurrent"] = this.isCurrent;
    data["Id"] = this.id;
    return data;
  }
}

export interface IGraphNode {
  /** Title */
  title?: string | undefined;
  /** Text */
  text?: string | undefined;
  /** IsCurrent */
  isCurrent?: boolean;
  /** Id */
  id?: string | undefined;
}

/** Represents hardware inventory information. */
export class Hardware implements IHardware {
  /** Gets or sets the list item ID. */
  listItemId?: string | undefined;
  /** Gets or sets the article stamm ID. */
  artikelStammId?: string | undefined;
  /** Gets or sets the display name. */
  displayName?: string | undefined;
  /** Gets or sets the department. */
  abteilung?: string | undefined;
  /** Gets or sets the main department. */
  hauptabteilung?: string | undefined;
  /** Gets or sets the device type. */
  geraeteArt?: string | undefined;
  /** Gets or sets the manufacturer model. */
  herstellerModell?: string | undefined;
  /** Gets or sets the BG label. */
  bgLabel?: string | undefined;
  /** Gets or sets the serial number. */
  seriennummer?: string | undefined;
  /** Gets or sets the telework flag. */
  telearbeit?: boolean | undefined;
  homeoffice?: boolean | undefined;
  /** Gets or sets the manufacturer. */
  hersteller?: string | undefined;
  /** Gets or sets the model. */
  modell?: string | undefined;
  /** Gets or sets the installation location. */
  aufstellungsort?: string | undefined;
  /** Gets or sets the room type. */
  raumtyp?: string | undefined;
  /** Gets or sets the location. */
  standort?: string | undefined;
  /** Gets or sets the room. */
  raum?: string | undefined;
  /** Gets or sets any other remarks. */
  sonstigeBemerkung?: string | undefined;
  /** Gets or sets the device name. */
  geraetename?: string | undefined;
  /** Gets or sets the availability flag. */
  vorhanden?: boolean | undefined;
  /** Gets or sets the reason. */
  grund?: string | undefined;
  /** Gets or sets the user hardware image. */
  userHardwareBild?: string | undefined;
  /** Gets or sets the article ID. */
  artikelId?: string | undefined;
  /** Gets or sets the shopping cart list item ID. */
  warenkorbListItemId?: string | undefined;
  userAdded?: boolean | undefined;

  constructor(data?: IHardware) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.listItemId = _data["ListItemId"];
      this.artikelStammId = _data["ArtikelStammId"];
      this.displayName = _data["DisplayName"];
      this.abteilung = _data["Abteilung"];
      this.hauptabteilung = _data["Hauptabteilung"];
      this.geraeteArt = _data["GeraeteArt"];
      this.herstellerModell = _data["HerstellerModell"];
      this.bgLabel = _data["BgLabel"];
      this.seriennummer = _data["Seriennummer"];
      this.telearbeit = _data["Telearbeit"];
      this.homeoffice = _data["Homeoffice"];
      this.hersteller = _data["Hersteller"];
      this.modell = _data["Modell"];
      this.aufstellungsort = _data["Aufstellungsort"];
      this.raumtyp = _data["Raumtyp"];
      this.standort = _data["Standort"];
      this.raum = _data["Raum"];
      this.sonstigeBemerkung = _data["SonstigeBemerkung"];
      this.geraetename = _data["Geraetename"];
      this.vorhanden = _data["Vorhanden"];
      this.grund = _data["Grund"];
      this.userHardwareBild = _data["UserHardwareBild"];
      this.artikelId = _data["ArtikelId"];
      this.warenkorbListItemId = _data["WarenkorbListItemId"];
      this.userAdded = _data["UserAdded"];
    }
  }

  static fromJS(data: any): Hardware {
    data = typeof data === "object" ? data : {};
    let result = new Hardware();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ListItemId"] = this.listItemId;
    data["ArtikelStammId"] = this.artikelStammId;
    data["DisplayName"] = this.displayName;
    data["Abteilung"] = this.abteilung;
    data["Hauptabteilung"] = this.hauptabteilung;
    data["GeraeteArt"] = this.geraeteArt;
    data["HerstellerModell"] = this.herstellerModell;
    data["BgLabel"] = this.bgLabel;
    data["Seriennummer"] = this.seriennummer;
    data["Telearbeit"] = this.telearbeit;
    data["Homeoffice"] = this.homeoffice;
    data["Hersteller"] = this.hersteller;
    data["Modell"] = this.modell;
    data["Aufstellungsort"] = this.aufstellungsort;
    data["Raumtyp"] = this.raumtyp;
    data["Standort"] = this.standort;
    data["Raum"] = this.raum;
    data["SonstigeBemerkung"] = this.sonstigeBemerkung;
    data["Geraetename"] = this.geraetename;
    data["Vorhanden"] = this.vorhanden;
    data["Grund"] = this.grund;
    data["UserHardwareBild"] = this.userHardwareBild;
    data["ArtikelId"] = this.artikelId;
    data["WarenkorbListItemId"] = this.warenkorbListItemId;
    data["UserAdded"] = this.userAdded;
    return data;
  }
}

/** Represents hardware inventory information. */
export interface IHardware {
  /** Gets or sets the list item ID. */
  listItemId?: string | undefined;
  /** Gets or sets the article stamm ID. */
  artikelStammId?: string | undefined;
  /** Gets or sets the display name. */
  displayName?: string | undefined;
  /** Gets or sets the department. */
  abteilung?: string | undefined;
  /** Gets or sets the main department. */
  hauptabteilung?: string | undefined;
  /** Gets or sets the device type. */
  geraeteArt?: string | undefined;
  /** Gets or sets the manufacturer model. */
  herstellerModell?: string | undefined;
  /** Gets or sets the BG label. */
  bgLabel?: string | undefined;
  /** Gets or sets the serial number. */
  seriennummer?: string | undefined;
  /** Gets or sets the telework flag. */
  telearbeit?: boolean | undefined;
  homeoffice?: boolean | undefined;
  /** Gets or sets the manufacturer. */
  hersteller?: string | undefined;
  /** Gets or sets the model. */
  modell?: string | undefined;
  /** Gets or sets the installation location. */
  aufstellungsort?: string | undefined;
  /** Gets or sets the room type. */
  raumtyp?: string | undefined;
  /** Gets or sets the location. */
  standort?: string | undefined;
  /** Gets or sets the room. */
  raum?: string | undefined;
  /** Gets or sets any other remarks. */
  sonstigeBemerkung?: string | undefined;
  /** Gets or sets the device name. */
  geraetename?: string | undefined;
  /** Gets or sets the availability flag. */
  vorhanden?: boolean | undefined;
  /** Gets or sets the reason. */
  grund?: string | undefined;
  /** Gets or sets the user hardware image. */
  userHardwareBild?: string | undefined;
  /** Gets or sets the article ID. */
  artikelId?: string | undefined;
  /** Gets or sets the shopping cart list item ID. */
  warenkorbListItemId?: string | undefined;
  userAdded?: boolean | undefined;
}

export class HelpdeskTicketCreationDto implements IHelpdeskTicketCreationDto {
  /** Issue Type, z. B. "Incident", "Service Request", "Bug". */
  issueType?: string | undefined;
  /** Kurzer Titel / Summary des Tickets. */
  title?: string | undefined;
  /** Ausführliche Beschreibung. */
  description?: string | undefined;

  constructor(data?: IHelpdeskTicketCreationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.issueType = _data["IssueType"];
      this.title = _data["Title"];
      this.description = _data["Description"];
    }
  }

  static fromJS(data: any): HelpdeskTicketCreationDto {
    data = typeof data === "object" ? data : {};
    let result = new HelpdeskTicketCreationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["IssueType"] = this.issueType;
    data["Title"] = this.title;
    data["Description"] = this.description;
    return data;
  }
}

export interface IHelpdeskTicketCreationDto {
  /** Issue Type, z. B. "Incident", "Service Request", "Bug". */
  issueType?: string | undefined;
  /** Kurzer Titel / Summary des Tickets. */
  title?: string | undefined;
  /** Ausführliche Beschreibung. */
  description?: string | undefined;
}

export class HelpdeskTicketItem implements IHelpdeskTicketItem {
  iD?: string | undefined;
  title?: string | undefined;
  status?: string | undefined;
  dateReceived?: Date | undefined;
  dateSolved?: Date | undefined;
  solution?: string | undefined;
  clientType?: string | undefined;

  constructor(data?: IHelpdeskTicketItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.iD = _data["ID"];
      this.title = _data["Title"];
      this.status = _data["Status"];
      this.dateReceived = _data["DateReceived"] ? new Date(_data["DateReceived"].toString()) : <any>undefined;
      this.dateSolved = _data["DateSolved"] ? new Date(_data["DateSolved"].toString()) : <any>undefined;
      this.solution = _data["Solution"];
      this.clientType = _data["ClientType"];
    }
  }

  static fromJS(data: any): HelpdeskTicketItem {
    data = typeof data === "object" ? data : {};
    let result = new HelpdeskTicketItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ID"] = this.iD;
    data["Title"] = this.title;
    data["Status"] = this.status;
    data["DateReceived"] = this.dateReceived ? this.dateReceived.toISOString() : <any>undefined;
    data["DateSolved"] = this.dateSolved ? this.dateSolved.toISOString() : <any>undefined;
    data["Solution"] = this.solution;
    data["ClientType"] = this.clientType;
    return data;
  }
}

export interface IHelpdeskTicketItem {
  iD?: string | undefined;
  title?: string | undefined;
  status?: string | undefined;
  dateReceived?: Date | undefined;
  dateSolved?: Date | undefined;
  solution?: string | undefined;
  clientType?: string | undefined;
}

export class Incident implements IIncident {
  title?: string | undefined;
  url?: string | undefined;
  betriebsstufe?: string | undefined;
  art?: string | undefined;
  start?: Date;
  lastModified?: Date;

  constructor(data?: IIncident) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["Title"];
      this.url = _data["Url"];
      this.betriebsstufe = _data["Betriebsstufe"];
      this.art = _data["Art"];
      this.start = _data["Start"] ? new Date(_data["Start"].toString()) : <any>undefined;
      this.lastModified = _data["LastModified"] ? new Date(_data["LastModified"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): Incident {
    data = typeof data === "object" ? data : {};
    let result = new Incident();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Title"] = this.title;
    data["Url"] = this.url;
    data["Betriebsstufe"] = this.betriebsstufe;
    data["Art"] = this.art;
    data["Start"] = this.start ? this.start.toISOString() : <any>undefined;
    data["LastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
    return data;
  }
}

export interface IIncident {
  title?: string | undefined;
  url?: string | undefined;
  betriebsstufe?: string | undefined;
  art?: string | undefined;
  start?: Date;
  lastModified?: Date;
}

export class IncidentDetails implements IIncidentDetails {
  title?: string | undefined;
  beschreibung?: string | undefined;
  mandant?: string[] | undefined;
  betriebsstufe?: string | undefined;
  start?: Date;
  end?: Date;
  ursache?: string | undefined;
  ausfallprotokoll?: string | undefined;
  incidentHistoryEntries?: IncidentHistory[] | undefined;

  constructor(data?: IIncidentDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["Title"];
      this.beschreibung = _data["Beschreibung"];
      if (Array.isArray(_data["Mandant"])) {
        this.mandant = [] as any;
        for (let item of _data["Mandant"]) this.mandant!.push(item);
      }
      this.betriebsstufe = _data["Betriebsstufe"];
      this.start = _data["Start"] ? new Date(_data["Start"].toString()) : <any>undefined;
      this.end = _data["End"] ? new Date(_data["End"].toString()) : <any>undefined;
      this.ursache = _data["Ursache"];
      this.ausfallprotokoll = _data["Ausfallprotokoll"];
      if (Array.isArray(_data["IncidentHistoryEntries"])) {
        this.incidentHistoryEntries = [] as any;
        for (let item of _data["IncidentHistoryEntries"]) this.incidentHistoryEntries!.push(IncidentHistory.fromJS(item));
      }
    }
  }

  static fromJS(data: any): IncidentDetails {
    data = typeof data === "object" ? data : {};
    let result = new IncidentDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Title"] = this.title;
    data["Beschreibung"] = this.beschreibung;
    if (Array.isArray(this.mandant)) {
      data["Mandant"] = [];
      for (let item of this.mandant) data["Mandant"].push(item);
    }
    data["Betriebsstufe"] = this.betriebsstufe;
    data["Start"] = this.start ? this.start.toISOString() : <any>undefined;
    data["End"] = this.end ? this.end.toISOString() : <any>undefined;
    data["Ursache"] = this.ursache;
    data["Ausfallprotokoll"] = this.ausfallprotokoll;
    if (Array.isArray(this.incidentHistoryEntries)) {
      data["IncidentHistoryEntries"] = [];
      for (let item of this.incidentHistoryEntries) data["IncidentHistoryEntries"].push(item.toJSON());
    }
    return data;
  }
}

export interface IIncidentDetails {
  title?: string | undefined;
  beschreibung?: string | undefined;
  mandant?: string[] | undefined;
  betriebsstufe?: string | undefined;
  start?: Date;
  end?: Date;
  ursache?: string | undefined;
  ausfallprotokoll?: string | undefined;
  incidentHistoryEntries?: IncidentHistory[] | undefined;
}

export class IncidentHistory implements IIncidentHistory {
  id?: string | undefined;
  von?: Date;
  bis?: Date;
  beschreibungDerAktion?: string | undefined;
  durchgefuehrtVon?: string | undefined;
  beschreibungDesErgebnisses?: string | undefined;
  author?: string | undefined;

  constructor(data?: IIncidentHistory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["Id"];
      this.von = _data["Von"] ? new Date(_data["Von"].toString()) : <any>undefined;
      this.bis = _data["Bis"] ? new Date(_data["Bis"].toString()) : <any>undefined;
      this.beschreibungDerAktion = _data["BeschreibungDerAktion"];
      this.durchgefuehrtVon = _data["DurchgefuehrtVon"];
      this.beschreibungDesErgebnisses = _data["BeschreibungDesErgebnisses"];
      this.author = _data["Author"];
    }
  }

  static fromJS(data: any): IncidentHistory {
    data = typeof data === "object" ? data : {};
    let result = new IncidentHistory();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["Von"] = this.von ? this.von.toISOString() : <any>undefined;
    data["Bis"] = this.bis ? this.bis.toISOString() : <any>undefined;
    data["BeschreibungDerAktion"] = this.beschreibungDerAktion;
    data["DurchgefuehrtVon"] = this.durchgefuehrtVon;
    data["BeschreibungDesErgebnisses"] = this.beschreibungDesErgebnisses;
    data["Author"] = this.author;
    return data;
  }
}

export interface IIncidentHistory {
  id?: string | undefined;
  von?: Date;
  bis?: Date;
  beschreibungDerAktion?: string | undefined;
  durchgefuehrtVon?: string | undefined;
  beschreibungDesErgebnisses?: string | undefined;
  author?: string | undefined;
}

export class IncidentMandant implements IIncidentMandant {
  mandant?: string | undefined;
  mandantLinkUrl?: string | undefined;
  logoPath?: string | undefined;
  logoAlt?: string | undefined;
  stoerungen?: Incident[] | undefined;
  wartungen?: Incident[] | undefined;

  constructor(data?: IIncidentMandant) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.mandant = _data["Mandant"];
      this.mandantLinkUrl = _data["MandantLinkUrl"];
      this.logoPath = _data["LogoPath"];
      this.logoAlt = _data["LogoAlt"];
      if (Array.isArray(_data["Stoerungen"])) {
        this.stoerungen = [] as any;
        for (let item of _data["Stoerungen"]) this.stoerungen!.push(Incident.fromJS(item));
      }
      if (Array.isArray(_data["Wartungen"])) {
        this.wartungen = [] as any;
        for (let item of _data["Wartungen"]) this.wartungen!.push(Incident.fromJS(item));
      }
    }
  }

  static fromJS(data: any): IncidentMandant {
    data = typeof data === "object" ? data : {};
    let result = new IncidentMandant();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Mandant"] = this.mandant;
    data["MandantLinkUrl"] = this.mandantLinkUrl;
    data["LogoPath"] = this.logoPath;
    data["LogoAlt"] = this.logoAlt;
    if (Array.isArray(this.stoerungen)) {
      data["Stoerungen"] = [];
      for (let item of this.stoerungen) data["Stoerungen"].push(item.toJSON());
    }
    if (Array.isArray(this.wartungen)) {
      data["Wartungen"] = [];
      for (let item of this.wartungen) data["Wartungen"].push(item.toJSON());
    }
    return data;
  }
}

export interface IIncidentMandant {
  mandant?: string | undefined;
  mandantLinkUrl?: string | undefined;
  logoPath?: string | undefined;
  logoAlt?: string | undefined;
  stoerungen?: Incident[] | undefined;
  wartungen?: Incident[] | undefined;
}

/** Represents the inventory of hardware. */
export class Inventory implements IInventory {
  tabs?: InventoryTab[] | undefined;
  delegatedTo?: string[] | undefined;

  constructor(data?: IInventory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["Tabs"])) {
        this.tabs = [] as any;
        for (let item of _data["Tabs"]) this.tabs!.push(InventoryTab.fromJS(item));
      }
      if (Array.isArray(_data["DelegatedTo"])) {
        this.delegatedTo = [] as any;
        for (let item of _data["DelegatedTo"]) this.delegatedTo!.push(item);
      }
    }
  }

  static fromJS(data: any): Inventory {
    data = typeof data === "object" ? data : {};
    let result = new Inventory();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.tabs)) {
      data["Tabs"] = [];
      for (let item of this.tabs) data["Tabs"].push(item.toJSON());
    }
    if (Array.isArray(this.delegatedTo)) {
      data["DelegatedTo"] = [];
      for (let item of this.delegatedTo) data["DelegatedTo"].push(item);
    }
    return data;
  }
}

/** Represents the inventory of hardware. */
export interface IInventory {
  tabs?: InventoryTab[] | undefined;
  delegatedTo?: string[] | undefined;
}

export class InventoryReportItem implements IInventoryReportItem {
  standort?: string | undefined;
  typ?: string | undefined;
  status?: string | undefined;
  anzahl?: number;

  constructor(data?: IInventoryReportItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.standort = _data["Standort"];
      this.typ = _data["Typ"];
      this.status = _data["Status"];
      this.anzahl = _data["Anzahl"];
    }
  }

  static fromJS(data: any): InventoryReportItem {
    data = typeof data === "object" ? data : {};
    let result = new InventoryReportItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Standort"] = this.standort;
    data["Typ"] = this.typ;
    data["Status"] = this.status;
    data["Anzahl"] = this.anzahl;
    return data;
  }
}

export interface IInventoryReportItem {
  standort?: string | undefined;
  typ?: string | undefined;
  status?: string | undefined;
  anzahl?: number;
}

export class InventoryTab implements IInventoryTab {
  id?: string | undefined;
  title?: string | undefined;
  userId?: string | undefined;
  type?: string | undefined;
  /** Gets or sets a value indicating whether the inventory is completed. */
  finished?: boolean;
  /** Gets or sets the date when the inventory was completed. */
  finishedDate?: Date | undefined;
  /** Gets or sets the list of hardware items. */
  hardwareList?: Hardware[] | undefined;

  constructor(data?: IInventoryTab) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["Id"];
      this.title = _data["Title"];
      this.userId = _data["UserId"];
      this.type = _data["Type"];
      this.finished = _data["Finished"];
      this.finishedDate = _data["FinishedDate"] ? new Date(_data["FinishedDate"].toString()) : <any>undefined;
      if (Array.isArray(_data["HardwareList"])) {
        this.hardwareList = [] as any;
        for (let item of _data["HardwareList"]) this.hardwareList!.push(Hardware.fromJS(item));
      }
    }
  }

  static fromJS(data: any): InventoryTab {
    data = typeof data === "object" ? data : {};
    let result = new InventoryTab();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["Title"] = this.title;
    data["UserId"] = this.userId;
    data["Type"] = this.type;
    data["Finished"] = this.finished;
    data["FinishedDate"] = this.finishedDate ? this.finishedDate.toISOString() : <any>undefined;
    if (Array.isArray(this.hardwareList)) {
      data["HardwareList"] = [];
      for (let item of this.hardwareList) data["HardwareList"].push(item.toJSON());
    }
    return data;
  }
}

export interface IInventoryTab {
  id?: string | undefined;
  title?: string | undefined;
  userId?: string | undefined;
  type?: string | undefined;
  /** Gets or sets a value indicating whether the inventory is completed. */
  finished?: boolean;
  /** Gets or sets the date when the inventory was completed. */
  finishedDate?: Date | undefined;
  /** Gets or sets the list of hardware items. */
  hardwareList?: Hardware[] | undefined;
}

export class JsonElement implements IJsonElement {
  valueKind?: JsonValueKind;

  constructor(data?: IJsonElement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.valueKind = _data["ValueKind"];
    }
  }

  static fromJS(data: any): JsonElement {
    data = typeof data === "object" ? data : {};
    let result = new JsonElement();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ValueKind"] = this.valueKind;
    return data;
  }
}

export interface IJsonElement {
  valueKind?: JsonValueKind;
}

export enum JsonValueKind {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _3 = 3,
  _4 = 4,
  _5 = 5,
  _6 = 6,
  _7 = 7
}

export class KalenderEintragDto implements IKalenderEintragDto {
  title?: string | undefined;
  webUrl?: string | undefined;
  formName?: string | undefined;
  beschreibung?: string | undefined;
  datumVon?: Date;
  datumBis?: Date;
  begruendung?: string | undefined;
  aktionen?: string[] | undefined;
  kategorien?: string[] | undefined;

  constructor(data?: IKalenderEintragDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["Title"];
      this.webUrl = _data["WebUrl"];
      this.formName = _data["FormName"];
      this.beschreibung = _data["Beschreibung"];
      this.datumVon = _data["DatumVon"] ? new Date(_data["DatumVon"].toString()) : <any>undefined;
      this.datumBis = _data["DatumBis"] ? new Date(_data["DatumBis"].toString()) : <any>undefined;
      this.begruendung = _data["Begruendung"];
      if (Array.isArray(_data["Aktionen"])) {
        this.aktionen = [] as any;
        for (let item of _data["Aktionen"]) this.aktionen!.push(item);
      }
      if (Array.isArray(_data["Kategorien"])) {
        this.kategorien = [] as any;
        for (let item of _data["Kategorien"]) this.kategorien!.push(item);
      }
    }
  }

  static fromJS(data: any): KalenderEintragDto {
    data = typeof data === "object" ? data : {};
    let result = new KalenderEintragDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Title"] = this.title;
    data["WebUrl"] = this.webUrl;
    data["FormName"] = this.formName;
    data["Beschreibung"] = this.beschreibung;
    data["DatumVon"] = this.datumVon ? this.datumVon.toISOString() : <any>undefined;
    data["DatumBis"] = this.datumBis ? this.datumBis.toISOString() : <any>undefined;
    data["Begruendung"] = this.begruendung;
    if (Array.isArray(this.aktionen)) {
      data["Aktionen"] = [];
      for (let item of this.aktionen) data["Aktionen"].push(item);
    }
    if (Array.isArray(this.kategorien)) {
      data["Kategorien"] = [];
      for (let item of this.kategorien) data["Kategorien"].push(item);
    }
    return data;
  }
}

export interface IKalenderEintragDto {
  title?: string | undefined;
  webUrl?: string | undefined;
  formName?: string | undefined;
  beschreibung?: string | undefined;
  datumVon?: Date;
  datumBis?: Date;
  begruendung?: string | undefined;
  aktionen?: string[] | undefined;
  kategorien?: string[] | undefined;
}

export class ListSchemaViewModel implements IListSchemaViewModel {
  webUrl?: string | undefined;
  listName?: string | undefined;
  fields?: FieldInfoViewModel[] | undefined;

  constructor(data?: IListSchemaViewModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.webUrl = _data["WebUrl"];
      this.listName = _data["ListName"];
      if (Array.isArray(_data["Fields"])) {
        this.fields = [] as any;
        for (let item of _data["Fields"]) this.fields!.push(FieldInfoViewModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ListSchemaViewModel {
    data = typeof data === "object" ? data : {};
    let result = new ListSchemaViewModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["WebUrl"] = this.webUrl;
    data["ListName"] = this.listName;
    if (Array.isArray(this.fields)) {
      data["Fields"] = [];
      for (let item of this.fields) data["Fields"].push(item.toJSON());
    }
    return data;
  }
}

export interface IListSchemaViewModel {
  webUrl?: string | undefined;
  listName?: string | undefined;
  fields?: FieldInfoViewModel[] | undefined;
}

export class OrgUnitInfo implements IOrgUnitInfo {
  orgUnitDescription?: string | undefined;
  organigrammLink?: string | undefined;

  constructor(data?: IOrgUnitInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.orgUnitDescription = _data["OrgUnitDescription"];
      this.organigrammLink = _data["OrganigrammLink"];
    }
  }

  static fromJS(data: any): OrgUnitInfo {
    data = typeof data === "object" ? data : {};
    let result = new OrgUnitInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["OrgUnitDescription"] = this.orgUnitDescription;
    data["OrganigrammLink"] = this.organigrammLink;
    return data;
  }
}

export interface IOrgUnitInfo {
  orgUnitDescription?: string | undefined;
  organigrammLink?: string | undefined;
}

export class Organisation implements IOrganisation {
  organisationsId?: string | undefined;
  ebene?: string | undefined;
  kurztext?: string | undefined;
  langtext?: string | undefined;
  organisationsId_Uebergeordnet?: string | undefined;
  kostenstelle?: string | undefined;
  gueltigVon?: Date;
  gueltigBis?: Date;
  path?: string | undefined;

  constructor(data?: IOrganisation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.organisationsId = _data["OrganisationsId"];
      this.ebene = _data["Ebene"];
      this.kurztext = _data["Kurztext"];
      this.langtext = _data["Langtext"];
      this.organisationsId_Uebergeordnet = _data["OrganisationsId_Uebergeordnet"];
      this.kostenstelle = _data["Kostenstelle"];
      this.gueltigVon = _data["GueltigVon"] ? new Date(_data["GueltigVon"].toString()) : <any>undefined;
      this.gueltigBis = _data["GueltigBis"] ? new Date(_data["GueltigBis"].toString()) : <any>undefined;
      this.path = _data["Path"];
    }
  }

  static fromJS(data: any): Organisation {
    data = typeof data === "object" ? data : {};
    let result = new Organisation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["OrganisationsId"] = this.organisationsId;
    data["Ebene"] = this.ebene;
    data["Kurztext"] = this.kurztext;
    data["Langtext"] = this.langtext;
    data["OrganisationsId_Uebergeordnet"] = this.organisationsId_Uebergeordnet;
    data["Kostenstelle"] = this.kostenstelle;
    data["GueltigVon"] = this.gueltigVon ? this.gueltigVon.toISOString() : <any>undefined;
    data["GueltigBis"] = this.gueltigBis ? this.gueltigBis.toISOString() : <any>undefined;
    data["Path"] = this.path;
    return data;
  }
}

export interface IOrganisation {
  organisationsId?: string | undefined;
  ebene?: string | undefined;
  kurztext?: string | undefined;
  langtext?: string | undefined;
  organisationsId_Uebergeordnet?: string | undefined;
  kostenstelle?: string | undefined;
  gueltigVon?: Date;
  gueltigBis?: Date;
  path?: string | undefined;
}

/** Represents metadata for a person photo without the actual image content. */
export class PersonPhotoMetadata implements IPersonPhotoMetadata {
  /** The personnel number. */
  personalnummer?: string | undefined;
  /** The name of the person. */
  name?: string | undefined;
  /** The organizational unit. */
  orgUnit?: string | undefined;
  /** Indicates whether the person has granted permission to distribute their photo. */
  distributionPermission?: boolean;
  /** Indicates whether a photo exists for this person. */
  hasPhoto?: boolean;
  status?: PersonPhotoRetrievalStatus;

  constructor(data?: IPersonPhotoMetadata) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.personalnummer = _data["Personalnummer"];
      this.name = _data["Name"];
      this.orgUnit = _data["OrgUnit"];
      this.distributionPermission = _data["DistributionPermission"];
      this.hasPhoto = _data["HasPhoto"];
      this.status = _data["Status"];
    }
  }

  static fromJS(data: any): PersonPhotoMetadata {
    data = typeof data === "object" ? data : {};
    let result = new PersonPhotoMetadata();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Personalnummer"] = this.personalnummer;
    data["Name"] = this.name;
    data["OrgUnit"] = this.orgUnit;
    data["DistributionPermission"] = this.distributionPermission;
    data["HasPhoto"] = this.hasPhoto;
    data["Status"] = this.status;
    return data;
  }
}

/** Represents metadata for a person photo without the actual image content. */
export interface IPersonPhotoMetadata {
  /** The personnel number. */
  personalnummer?: string | undefined;
  /** The name of the person. */
  name?: string | undefined;
  /** The organizational unit. */
  orgUnit?: string | undefined;
  /** Indicates whether the person has granted permission to distribute their photo. */
  distributionPermission?: boolean;
  /** Indicates whether a photo exists for this person. */
  hasPhoto?: boolean;
  status?: PersonPhotoRetrievalStatus;
}

export enum PersonPhotoRetrievalStatus {
  _0 = 0,
  _1 = 1,
  _2 = 2,
  _3 = 3
}

export class ProblemDetails implements IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.type = _data["Type"];
      this.title = _data["Title"];
      this.status = _data["Status"];
      this.detail = _data["Detail"];
      this.instance = _data["Instance"];
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === "object" ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["Type"] = this.type;
    data["Title"] = this.title;
    data["Status"] = this.status;
    data["Detail"] = this.detail;
    data["Instance"] = this.instance;
    return data;
  }
}

export interface IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;

  [key: string]: any;
}

export class Role implements IRole {
  displayName?: string | undefined;
  key?: string | undefined;

  constructor(data?: IRole) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.displayName = _data["DisplayName"];
      this.key = _data["Key"];
    }
  }

  static fromJS(data: any): Role {
    data = typeof data === "object" ? data : {};
    let result = new Role();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["DisplayName"] = this.displayName;
    data["Key"] = this.key;
    return data;
  }
}

export interface IRole {
  displayName?: string | undefined;
  key?: string | undefined;
}

/** Search query model for Elasticsearch */
export class SearchQuery implements ISearchQuery {
  /** Client identifier */
  clientId?: string | undefined;
  /** Query text for full-text search */
  queryText?: string | undefined;
  /** List of search properties/filters */
  searchProperties?: FileNetProperty[] | undefined;
  /** Index alias to search */
  indexAlias?: string | undefined;
  /** Number of rows per page */
  rowsPerPage?: number;
  /** Current page index (0-based) */
  currentPageIndex?: number;
  sortColumn?: FileNetProperty;
  /** Sort direction (asc/desc) */
  sortDirection?: string | undefined;
  /** Properties to include in results */
  resultProperties?: FileNetProperty[] | undefined;
  /** Whether to show Aktenzeichen button */
  showAktenzeichenBtn?: boolean;

  constructor(data?: ISearchQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.clientId = _data["clientId"];
      this.queryText = _data["queryText"];
      if (Array.isArray(_data["searchProperties"])) {
        this.searchProperties = [] as any;
        for (let item of _data["searchProperties"]) this.searchProperties!.push(FileNetProperty.fromJS(item));
      }
      this.indexAlias = _data["indexAlias"];
      this.rowsPerPage = _data["rowsPerPage"];
      this.currentPageIndex = _data["currentPageIndex"];
      this.sortColumn = _data["sortColumn"] ? FileNetProperty.fromJS(_data["sortColumn"]) : <any>undefined;
      this.sortDirection = _data["sortDirection"];
      if (Array.isArray(_data["resultProperties"])) {
        this.resultProperties = [] as any;
        for (let item of _data["resultProperties"]) this.resultProperties!.push(FileNetProperty.fromJS(item));
      }
      this.showAktenzeichenBtn = _data["showAktenzeichenBtn"];
    }
  }

  static fromJS(data: any): SearchQuery {
    data = typeof data === "object" ? data : {};
    let result = new SearchQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["clientId"] = this.clientId;
    data["queryText"] = this.queryText;
    if (Array.isArray(this.searchProperties)) {
      data["searchProperties"] = [];
      for (let item of this.searchProperties) data["searchProperties"].push(item.toJSON());
    }
    data["indexAlias"] = this.indexAlias;
    data["rowsPerPage"] = this.rowsPerPage;
    data["currentPageIndex"] = this.currentPageIndex;
    data["sortColumn"] = this.sortColumn ? this.sortColumn.toJSON() : <any>undefined;
    data["sortDirection"] = this.sortDirection;
    if (Array.isArray(this.resultProperties)) {
      data["resultProperties"] = [];
      for (let item of this.resultProperties) data["resultProperties"].push(item.toJSON());
    }
    data["showAktenzeichenBtn"] = this.showAktenzeichenBtn;
    return data;
  }
}

/** Search query model for Elasticsearch */
export interface ISearchQuery {
  /** Client identifier */
  clientId?: string | undefined;
  /** Query text for full-text search */
  queryText?: string | undefined;
  /** List of search properties/filters */
  searchProperties?: FileNetProperty[] | undefined;
  /** Index alias to search */
  indexAlias?: string | undefined;
  /** Number of rows per page */
  rowsPerPage?: number;
  /** Current page index (0-based) */
  currentPageIndex?: number;
  sortColumn?: FileNetProperty;
  /** Sort direction (asc/desc) */
  sortDirection?: string | undefined;
  /** Properties to include in results */
  resultProperties?: FileNetProperty[] | undefined;
  /** Whether to show Aktenzeichen button */
  showAktenzeichenBtn?: boolean;
}

export class SendLogDto implements ISendLogDto {
  message?: string | undefined;
  stackTrace?: string | undefined;

  constructor(data?: ISendLogDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.message = _data["Message"];
      this.stackTrace = _data["StackTrace"];
    }
  }

  static fromJS(data: any): SendLogDto {
    data = typeof data === "object" ? data : {};
    let result = new SendLogDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Message"] = this.message;
    data["StackTrace"] = this.stackTrace;
    return data;
  }
}

export interface ISendLogDto {
  message?: string | undefined;
  stackTrace?: string | undefined;
}

export class ServiceCard implements IServiceCard {
  kartennummer?: string | undefined;
  ausweisTyp?: string | undefined;
  gueltigVon?: Date;
  gueltigBis?: Date;

  constructor(data?: IServiceCard) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.kartennummer = _data["Kartennummer"];
      this.ausweisTyp = _data["AusweisTyp"];
      this.gueltigVon = _data["GueltigVon"] ? new Date(_data["GueltigVon"].toString()) : <any>undefined;
      this.gueltigBis = _data["GueltigBis"] ? new Date(_data["GueltigBis"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): ServiceCard {
    data = typeof data === "object" ? data : {};
    let result = new ServiceCard();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Kartennummer"] = this.kartennummer;
    data["AusweisTyp"] = this.ausweisTyp;
    data["GueltigVon"] = this.gueltigVon ? this.gueltigVon.toISOString() : <any>undefined;
    data["GueltigBis"] = this.gueltigBis ? this.gueltigBis.toISOString() : <any>undefined;
    return data;
  }
}

export interface IServiceCard {
  kartennummer?: string | undefined;
  ausweisTyp?: string | undefined;
  gueltigVon?: Date;
  gueltigBis?: Date;
}

export class Software implements ISoftware {
  listItemId?: number;
  bild?: string | undefined;
  hersteller?: string | undefined;
  produkt?: string | undefined;
  link?: string | undefined;
  typ?: string | undefined;
  detailinformation?: string | undefined;
  erlaeuterung?: string | undefined;
  preis?: string | undefined;
  aDGroup?: string | undefined;
  siteUrl?: string | undefined;
  installUsers?: User[] | undefined;
  uninstallUsers?: User[] | undefined;

  constructor(data?: ISoftware) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.listItemId = _data["ListItemId"];
      this.bild = _data["Bild"];
      this.hersteller = _data["Hersteller"];
      this.produkt = _data["Produkt"];
      this.link = _data["Link"];
      this.typ = _data["Typ"];
      this.detailinformation = _data["Detailinformation"];
      this.erlaeuterung = _data["Erlaeuterung"];
      this.preis = _data["Preis"];
      this.aDGroup = _data["ADGroup"];
      this.siteUrl = _data["SiteUrl"];
      if (Array.isArray(_data["InstallUsers"])) {
        this.installUsers = [] as any;
        for (let item of _data["InstallUsers"]) this.installUsers!.push(User.fromJS(item));
      }
      if (Array.isArray(_data["UninstallUsers"])) {
        this.uninstallUsers = [] as any;
        for (let item of _data["UninstallUsers"]) this.uninstallUsers!.push(User.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Software {
    data = typeof data === "object" ? data : {};
    let result = new Software();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ListItemId"] = this.listItemId;
    data["Bild"] = this.bild;
    data["Hersteller"] = this.hersteller;
    data["Produkt"] = this.produkt;
    data["Link"] = this.link;
    data["Typ"] = this.typ;
    data["Detailinformation"] = this.detailinformation;
    data["Erlaeuterung"] = this.erlaeuterung;
    data["Preis"] = this.preis;
    data["ADGroup"] = this.aDGroup;
    data["SiteUrl"] = this.siteUrl;
    if (Array.isArray(this.installUsers)) {
      data["InstallUsers"] = [];
      for (let item of this.installUsers) data["InstallUsers"].push(item.toJSON());
    }
    if (Array.isArray(this.uninstallUsers)) {
      data["UninstallUsers"] = [];
      for (let item of this.uninstallUsers) data["UninstallUsers"].push(item.toJSON());
    }
    return data;
  }
}

export interface ISoftware {
  listItemId?: number;
  bild?: string | undefined;
  hersteller?: string | undefined;
  produkt?: string | undefined;
  link?: string | undefined;
  typ?: string | undefined;
  detailinformation?: string | undefined;
  erlaeuterung?: string | undefined;
  preis?: string | undefined;
  aDGroup?: string | undefined;
  siteUrl?: string | undefined;
  installUsers?: User[] | undefined;
  uninstallUsers?: User[] | undefined;
}

export class SurveyItem implements ISurveyItem {
  key?: string | undefined;
  ratings?: SurveyRatingItem[] | undefined;

  constructor(data?: ISurveyItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.key = _data["Key"];
      if (Array.isArray(_data["Ratings"])) {
        this.ratings = [] as any;
        for (let item of _data["Ratings"]) this.ratings!.push(SurveyRatingItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SurveyItem {
    data = typeof data === "object" ? data : {};
    let result = new SurveyItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Key"] = this.key;
    if (Array.isArray(this.ratings)) {
      data["Ratings"] = [];
      for (let item of this.ratings) data["Ratings"].push(item.toJSON());
    }
    return data;
  }
}

export interface ISurveyItem {
  key?: string | undefined;
  ratings?: SurveyRatingItem[] | undefined;
}

export class SurveyRatingItem implements ISurveyRatingItem {
  rating?: number | undefined;
  comment?: string | undefined;
  isRated?: boolean;

  constructor(data?: ISurveyRatingItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.rating = _data["Rating"];
      this.comment = _data["Comment"];
      this.isRated = _data["IsRated"];
    }
  }

  static fromJS(data: any): SurveyRatingItem {
    data = typeof data === "object" ? data : {};
    let result = new SurveyRatingItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Rating"] = this.rating;
    data["Comment"] = this.comment;
    data["IsRated"] = this.isRated;
    return data;
  }
}

export interface ISurveyRatingItem {
  rating?: number | undefined;
  comment?: string | undefined;
  isRated?: boolean;
}

export class UmsetzungITMassnahmeVersendenDto implements IUmsetzungITMassnahmeVersendenDto {
  personalnummer?: string | undefined;
  webUrl?: string | undefined;
  formName?: string | undefined;
  vorname?: string | undefined;
  nachname?: string | undefined;
  status?: string | undefined;
  datumVon?: Date;
  datumBis?: Date;
  userDomain?: string | undefined;
  systemId?: string | undefined;
  userLoginName?: string | undefined;

  constructor(data?: IUmsetzungITMassnahmeVersendenDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.personalnummer = _data["Personalnummer"];
      this.webUrl = _data["WebUrl"];
      this.formName = _data["FormName"];
      this.vorname = _data["Vorname"];
      this.nachname = _data["Nachname"];
      this.status = _data["Status"];
      this.datumVon = _data["DatumVon"] ? new Date(_data["DatumVon"].toString()) : <any>undefined;
      this.datumBis = _data["DatumBis"] ? new Date(_data["DatumBis"].toString()) : <any>undefined;
      this.userDomain = _data["UserDomain"];
      this.systemId = _data["SystemId"];
      this.userLoginName = _data["UserLoginName"];
    }
  }

  static fromJS(data: any): UmsetzungITMassnahmeVersendenDto {
    data = typeof data === "object" ? data : {};
    let result = new UmsetzungITMassnahmeVersendenDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Personalnummer"] = this.personalnummer;
    data["WebUrl"] = this.webUrl;
    data["FormName"] = this.formName;
    data["Vorname"] = this.vorname;
    data["Nachname"] = this.nachname;
    data["Status"] = this.status;
    data["DatumVon"] = this.datumVon ? this.datumVon.toISOString() : <any>undefined;
    data["DatumBis"] = this.datumBis ? this.datumBis.toISOString() : <any>undefined;
    data["UserDomain"] = this.userDomain;
    data["SystemId"] = this.systemId;
    data["UserLoginName"] = this.userLoginName;
    return data;
  }
}

export interface IUmsetzungITMassnahmeVersendenDto {
  personalnummer?: string | undefined;
  webUrl?: string | undefined;
  formName?: string | undefined;
  vorname?: string | undefined;
  nachname?: string | undefined;
  status?: string | undefined;
  datumVon?: Date;
  datumBis?: Date;
  userDomain?: string | undefined;
  systemId?: string | undefined;
  userLoginName?: string | undefined;
}

export class User implements IUser {
  personalnummer?: string | undefined;
  titel?: string | undefined;
  nachname?: string | undefined;
  vorname?: string | undefined;
  anrede?: string | undefined;
  geschlecht?: string | undefined;
  eintritt?: Date;
  austritt?: Date;
  diktatzeichen?: string | undefined;
  arbeitsplatz_Ort?: string | undefined;
  arbeitsplatz_Strasse?: string | undefined;
  arbeitsplatz_Postleitzahl?: string | undefined;
  arbeitsplatz_Raum?: string | undefined;
  telefon?: string | undefined;
  fax?: string | undefined;
  email?: string | undefined;
  handy?: string | undefined;
  kartennummer?: string | undefined;
  sipAdresse?: string | undefined;
  geburtsdatum?: Date;
  aufbereiteterName?: string | undefined;
  vorsatzwort?: string | undefined;
  sAP_GueltigVon?: Date;
  sAP_GueltigBis?: Date;
  mitarbeitergruppe?: string | undefined;
  mitarbeiterkreis?: string | undefined;
  kostenstelle?: string | undefined;
  altersteilzeit_D_Vollzeit_GueltigVon?: Date;
  altersteilzeit_D_Freistellung_GueltigVon?: Date;
  zugeordneteOrgEinheiten?: string | undefined;
  planstellenIds?: string[] | undefined;
  planstellenIdsAsString?: string | undefined;
  verknuepfungstext?: string | undefined;
  abteilung?: string | undefined;
  planstellenlangbezeichnung?: string | undefined;
  sachbearbeiterPersonal?: string | undefined;
  sachbearbeiterZeiterfassung?: string | undefined;
  sachbearbeiterAbrechnung?: string | undefined;
  firmenbezeichnung?: string | undefined;
  firmenkurzbezeichnung?: string | undefined;
  buchungskreis?: string | undefined;
  beschaeftigungsstatus?: string | undefined;
  kostenstellenartBezeichnung?: string | undefined;
  telearbeit?: boolean;
  wochenstunden?: number;
  fahrzeugart?: string | undefined;
  fahrzeugartBezeichnung?: string | undefined;
  systemId?: string | undefined;
  mandant?: string | undefined;

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.personalnummer = _data["Personalnummer"];
      this.titel = _data["Titel"];
      this.nachname = _data["Nachname"];
      this.vorname = _data["Vorname"];
      this.anrede = _data["Anrede"];
      this.geschlecht = _data["Geschlecht"];
      this.eintritt = _data["Eintritt"] ? new Date(_data["Eintritt"].toString()) : <any>undefined;
      this.austritt = _data["Austritt"] ? new Date(_data["Austritt"].toString()) : <any>undefined;
      this.diktatzeichen = _data["Diktatzeichen"];
      this.arbeitsplatz_Ort = _data["Arbeitsplatz_Ort"];
      this.arbeitsplatz_Strasse = _data["Arbeitsplatz_Strasse"];
      this.arbeitsplatz_Postleitzahl = _data["Arbeitsplatz_Postleitzahl"];
      this.arbeitsplatz_Raum = _data["Arbeitsplatz_Raum"];
      this.telefon = _data["Telefon"];
      this.fax = _data["Fax"];
      this.email = _data["Email"];
      this.handy = _data["Handy"];
      this.kartennummer = _data["Kartennummer"];
      this.sipAdresse = _data["SipAdresse"];
      this.geburtsdatum = _data["Geburtsdatum"] ? new Date(_data["Geburtsdatum"].toString()) : <any>undefined;
      this.aufbereiteterName = _data["AufbereiteterName"];
      this.vorsatzwort = _data["Vorsatzwort"];
      this.sAP_GueltigVon = _data["SAP_GueltigVon"] ? new Date(_data["SAP_GueltigVon"].toString()) : <any>undefined;
      this.sAP_GueltigBis = _data["SAP_GueltigBis"] ? new Date(_data["SAP_GueltigBis"].toString()) : <any>undefined;
      this.mitarbeitergruppe = _data["Mitarbeitergruppe"];
      this.mitarbeiterkreis = _data["Mitarbeiterkreis"];
      this.kostenstelle = _data["Kostenstelle"];
      this.altersteilzeit_D_Vollzeit_GueltigVon = _data["Altersteilzeit_D_Vollzeit_GueltigVon"] ? new Date(_data["Altersteilzeit_D_Vollzeit_GueltigVon"].toString()) : <any>undefined;
      this.altersteilzeit_D_Freistellung_GueltigVon = _data["Altersteilzeit_D_Freistellung_GueltigVon"] ? new Date(_data["Altersteilzeit_D_Freistellung_GueltigVon"].toString()) : <any>undefined;
      this.zugeordneteOrgEinheiten = _data["ZugeordneteOrgEinheiten"];
      if (Array.isArray(_data["PlanstellenIds"])) {
        this.planstellenIds = [] as any;
        for (let item of _data["PlanstellenIds"]) this.planstellenIds!.push(item);
      }
      this.planstellenIdsAsString = _data["PlanstellenIdsAsString"];
      this.verknuepfungstext = _data["Verknuepfungstext"];
      this.abteilung = _data["Abteilung"];
      this.planstellenlangbezeichnung = _data["Planstellenlangbezeichnung"];
      this.sachbearbeiterPersonal = _data["SachbearbeiterPersonal"];
      this.sachbearbeiterZeiterfassung = _data["SachbearbeiterZeiterfassung"];
      this.sachbearbeiterAbrechnung = _data["SachbearbeiterAbrechnung"];
      this.firmenbezeichnung = _data["Firmenbezeichnung"];
      this.firmenkurzbezeichnung = _data["Firmenkurzbezeichnung"];
      this.buchungskreis = _data["Buchungskreis"];
      this.beschaeftigungsstatus = _data["Beschaeftigungsstatus"];
      this.kostenstellenartBezeichnung = _data["KostenstellenartBezeichnung"];
      this.telearbeit = _data["Telearbeit"];
      this.wochenstunden = _data["Wochenstunden"];
      this.fahrzeugart = _data["Fahrzeugart"];
      this.fahrzeugartBezeichnung = _data["FahrzeugartBezeichnung"];
      this.systemId = _data["SystemId"];
      this.mandant = _data["Mandant"];
    }
  }

  static fromJS(data: any): User {
    data = typeof data === "object" ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Personalnummer"] = this.personalnummer;
    data["Titel"] = this.titel;
    data["Nachname"] = this.nachname;
    data["Vorname"] = this.vorname;
    data["Anrede"] = this.anrede;
    data["Geschlecht"] = this.geschlecht;
    data["Eintritt"] = this.eintritt ? this.eintritt.toISOString() : <any>undefined;
    data["Austritt"] = this.austritt ? this.austritt.toISOString() : <any>undefined;
    data["Diktatzeichen"] = this.diktatzeichen;
    data["Arbeitsplatz_Ort"] = this.arbeitsplatz_Ort;
    data["Arbeitsplatz_Strasse"] = this.arbeitsplatz_Strasse;
    data["Arbeitsplatz_Postleitzahl"] = this.arbeitsplatz_Postleitzahl;
    data["Arbeitsplatz_Raum"] = this.arbeitsplatz_Raum;
    data["Telefon"] = this.telefon;
    data["Fax"] = this.fax;
    data["Email"] = this.email;
    data["Handy"] = this.handy;
    data["Kartennummer"] = this.kartennummer;
    data["SipAdresse"] = this.sipAdresse;
    data["Geburtsdatum"] = this.geburtsdatum ? this.geburtsdatum.toISOString() : <any>undefined;
    data["AufbereiteterName"] = this.aufbereiteterName;
    data["Vorsatzwort"] = this.vorsatzwort;
    data["SAP_GueltigVon"] = this.sAP_GueltigVon ? this.sAP_GueltigVon.toISOString() : <any>undefined;
    data["SAP_GueltigBis"] = this.sAP_GueltigBis ? this.sAP_GueltigBis.toISOString() : <any>undefined;
    data["Mitarbeitergruppe"] = this.mitarbeitergruppe;
    data["Mitarbeiterkreis"] = this.mitarbeiterkreis;
    data["Kostenstelle"] = this.kostenstelle;
    data["Altersteilzeit_D_Vollzeit_GueltigVon"] = this.altersteilzeit_D_Vollzeit_GueltigVon ? this.altersteilzeit_D_Vollzeit_GueltigVon.toISOString() : <any>undefined;
    data["Altersteilzeit_D_Freistellung_GueltigVon"] = this.altersteilzeit_D_Freistellung_GueltigVon ? this.altersteilzeit_D_Freistellung_GueltigVon.toISOString() : <any>undefined;
    data["ZugeordneteOrgEinheiten"] = this.zugeordneteOrgEinheiten;
    if (Array.isArray(this.planstellenIds)) {
      data["PlanstellenIds"] = [];
      for (let item of this.planstellenIds) data["PlanstellenIds"].push(item);
    }
    data["PlanstellenIdsAsString"] = this.planstellenIdsAsString;
    data["Verknuepfungstext"] = this.verknuepfungstext;
    data["Abteilung"] = this.abteilung;
    data["Planstellenlangbezeichnung"] = this.planstellenlangbezeichnung;
    data["SachbearbeiterPersonal"] = this.sachbearbeiterPersonal;
    data["SachbearbeiterZeiterfassung"] = this.sachbearbeiterZeiterfassung;
    data["SachbearbeiterAbrechnung"] = this.sachbearbeiterAbrechnung;
    data["Firmenbezeichnung"] = this.firmenbezeichnung;
    data["Firmenkurzbezeichnung"] = this.firmenkurzbezeichnung;
    data["Buchungskreis"] = this.buchungskreis;
    data["Beschaeftigungsstatus"] = this.beschaeftigungsstatus;
    data["KostenstellenartBezeichnung"] = this.kostenstellenartBezeichnung;
    data["Telearbeit"] = this.telearbeit;
    data["Wochenstunden"] = this.wochenstunden;
    data["Fahrzeugart"] = this.fahrzeugart;
    data["FahrzeugartBezeichnung"] = this.fahrzeugartBezeichnung;
    data["SystemId"] = this.systemId;
    data["Mandant"] = this.mandant;
    return data;
  }
}

export interface IUser {
  personalnummer?: string | undefined;
  titel?: string | undefined;
  nachname?: string | undefined;
  vorname?: string | undefined;
  anrede?: string | undefined;
  geschlecht?: string | undefined;
  eintritt?: Date;
  austritt?: Date;
  diktatzeichen?: string | undefined;
  arbeitsplatz_Ort?: string | undefined;
  arbeitsplatz_Strasse?: string | undefined;
  arbeitsplatz_Postleitzahl?: string | undefined;
  arbeitsplatz_Raum?: string | undefined;
  telefon?: string | undefined;
  fax?: string | undefined;
  email?: string | undefined;
  handy?: string | undefined;
  kartennummer?: string | undefined;
  sipAdresse?: string | undefined;
  geburtsdatum?: Date;
  aufbereiteterName?: string | undefined;
  vorsatzwort?: string | undefined;
  sAP_GueltigVon?: Date;
  sAP_GueltigBis?: Date;
  mitarbeitergruppe?: string | undefined;
  mitarbeiterkreis?: string | undefined;
  kostenstelle?: string | undefined;
  altersteilzeit_D_Vollzeit_GueltigVon?: Date;
  altersteilzeit_D_Freistellung_GueltigVon?: Date;
  zugeordneteOrgEinheiten?: string | undefined;
  planstellenIds?: string[] | undefined;
  planstellenIdsAsString?: string | undefined;
  verknuepfungstext?: string | undefined;
  abteilung?: string | undefined;
  planstellenlangbezeichnung?: string | undefined;
  sachbearbeiterPersonal?: string | undefined;
  sachbearbeiterZeiterfassung?: string | undefined;
  sachbearbeiterAbrechnung?: string | undefined;
  firmenbezeichnung?: string | undefined;
  firmenkurzbezeichnung?: string | undefined;
  buchungskreis?: string | undefined;
  beschaeftigungsstatus?: string | undefined;
  kostenstellenartBezeichnung?: string | undefined;
  telearbeit?: boolean;
  wochenstunden?: number;
  fahrzeugart?: string | undefined;
  fahrzeugartBezeichnung?: string | undefined;
  systemId?: string | undefined;
  mandant?: string | undefined;
}

/** Represents a user presence result which can contain either presence information or error details */
export class UserPresenceResult implements IUserPresenceResult {
  /** The unique identifier of the user (populated on success) */
  id?: string | undefined;
  /** The availability status of the user (e.g., Available, Busy, Away, etc.) (populated on success) */
  availability?: string | undefined;
  /** The activity description of the user (e.g., In a call, In a meeting, etc.) (populated on success) */
  activity?: string | undefined;
  /** Error message if the presence information could not be retrieved (populated on error) */
  error?: string | undefined;
  /** Indicates whether this result represents a successful response or an error */
  readonly isSuccess?: boolean;

  constructor(data?: IUserPresenceResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["Id"];
      this.availability = _data["Availability"];
      this.activity = _data["Activity"];
      this.error = _data["Error"];
      (<any>this).isSuccess = _data["IsSuccess"];
    }
  }

  static fromJS(data: any): UserPresenceResult {
    data = typeof data === "object" ? data : {};
    let result = new UserPresenceResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["Id"] = this.id;
    data["Availability"] = this.availability;
    data["Activity"] = this.activity;
    data["Error"] = this.error;
    data["IsSuccess"] = this.isSuccess;
    return data;
  }
}

/** Represents a user presence result which can contain either presence information or error details */
export interface IUserPresenceResult {
  /** The unique identifier of the user (populated on success) */
  id?: string | undefined;
  /** The availability status of the user (e.g., Available, Busy, Away, etc.) (populated on success) */
  availability?: string | undefined;
  /** The activity description of the user (e.g., In a call, In a meeting, etc.) (populated on success) */
  activity?: string | undefined;
  /** Error message if the presence information could not be retrieved (populated on error) */
  error?: string | undefined;
  /** Indicates whether this result represents a successful response or an error */
  isSuccess?: boolean;
}

export class UserPrivateAddress implements IUserPrivateAddress {
  privateStraße?: string | undefined;
  privatePostleitzahl?: string | undefined;
  privateOrt?: string | undefined;
  dienststelle?: string | undefined;
  personalnummer?: string | undefined;
  titel?: string | undefined;
  nachname?: string | undefined;
  vorname?: string | undefined;
  anrede?: string | undefined;
  geschlecht?: string | undefined;
  eintritt?: Date;
  austritt?: Date;
  diktatzeichen?: string | undefined;
  arbeitsplatz_Ort?: string | undefined;
  arbeitsplatz_Strasse?: string | undefined;
  arbeitsplatz_Postleitzahl?: string | undefined;
  arbeitsplatz_Raum?: string | undefined;
  telefon?: string | undefined;
  fax?: string | undefined;
  email?: string | undefined;
  handy?: string | undefined;
  kartennummer?: string | undefined;
  sipAdresse?: string | undefined;
  geburtsdatum?: Date;
  aufbereiteterName?: string | undefined;
  vorsatzwort?: string | undefined;
  sAP_GueltigVon?: Date;
  sAP_GueltigBis?: Date;
  mitarbeitergruppe?: string | undefined;
  mitarbeiterkreis?: string | undefined;
  kostenstelle?: string | undefined;
  altersteilzeit_D_Vollzeit_GueltigVon?: Date;
  altersteilzeit_D_Freistellung_GueltigVon?: Date;
  zugeordneteOrgEinheiten?: string | undefined;
  planstellenIds?: string[] | undefined;
  planstellenIdsAsString?: string | undefined;
  verknuepfungstext?: string | undefined;
  abteilung?: string | undefined;
  planstellenlangbezeichnung?: string | undefined;
  sachbearbeiterPersonal?: string | undefined;
  sachbearbeiterZeiterfassung?: string | undefined;
  sachbearbeiterAbrechnung?: string | undefined;
  firmenbezeichnung?: string | undefined;
  firmenkurzbezeichnung?: string | undefined;
  buchungskreis?: string | undefined;
  beschaeftigungsstatus?: string | undefined;
  kostenstellenartBezeichnung?: string | undefined;
  telearbeit?: boolean;
  wochenstunden?: number;
  fahrzeugart?: string | undefined;
  fahrzeugartBezeichnung?: string | undefined;
  systemId?: string | undefined;
  mandant?: string | undefined;

  constructor(data?: IUserPrivateAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.privateStraße = _data["PrivateStraße"];
      this.privatePostleitzahl = _data["PrivatePostleitzahl"];
      this.privateOrt = _data["PrivateOrt"];
      this.dienststelle = _data["Dienststelle"];
      this.personalnummer = _data["Personalnummer"];
      this.titel = _data["Titel"];
      this.nachname = _data["Nachname"];
      this.vorname = _data["Vorname"];
      this.anrede = _data["Anrede"];
      this.geschlecht = _data["Geschlecht"];
      this.eintritt = _data["Eintritt"] ? new Date(_data["Eintritt"].toString()) : <any>undefined;
      this.austritt = _data["Austritt"] ? new Date(_data["Austritt"].toString()) : <any>undefined;
      this.diktatzeichen = _data["Diktatzeichen"];
      this.arbeitsplatz_Ort = _data["Arbeitsplatz_Ort"];
      this.arbeitsplatz_Strasse = _data["Arbeitsplatz_Strasse"];
      this.arbeitsplatz_Postleitzahl = _data["Arbeitsplatz_Postleitzahl"];
      this.arbeitsplatz_Raum = _data["Arbeitsplatz_Raum"];
      this.telefon = _data["Telefon"];
      this.fax = _data["Fax"];
      this.email = _data["Email"];
      this.handy = _data["Handy"];
      this.kartennummer = _data["Kartennummer"];
      this.sipAdresse = _data["SipAdresse"];
      this.geburtsdatum = _data["Geburtsdatum"] ? new Date(_data["Geburtsdatum"].toString()) : <any>undefined;
      this.aufbereiteterName = _data["AufbereiteterName"];
      this.vorsatzwort = _data["Vorsatzwort"];
      this.sAP_GueltigVon = _data["SAP_GueltigVon"] ? new Date(_data["SAP_GueltigVon"].toString()) : <any>undefined;
      this.sAP_GueltigBis = _data["SAP_GueltigBis"] ? new Date(_data["SAP_GueltigBis"].toString()) : <any>undefined;
      this.mitarbeitergruppe = _data["Mitarbeitergruppe"];
      this.mitarbeiterkreis = _data["Mitarbeiterkreis"];
      this.kostenstelle = _data["Kostenstelle"];
      this.altersteilzeit_D_Vollzeit_GueltigVon = _data["Altersteilzeit_D_Vollzeit_GueltigVon"] ? new Date(_data["Altersteilzeit_D_Vollzeit_GueltigVon"].toString()) : <any>undefined;
      this.altersteilzeit_D_Freistellung_GueltigVon = _data["Altersteilzeit_D_Freistellung_GueltigVon"] ? new Date(_data["Altersteilzeit_D_Freistellung_GueltigVon"].toString()) : <any>undefined;
      this.zugeordneteOrgEinheiten = _data["ZugeordneteOrgEinheiten"];
      if (Array.isArray(_data["PlanstellenIds"])) {
        this.planstellenIds = [] as any;
        for (let item of _data["PlanstellenIds"]) this.planstellenIds!.push(item);
      }
      this.planstellenIdsAsString = _data["PlanstellenIdsAsString"];
      this.verknuepfungstext = _data["Verknuepfungstext"];
      this.abteilung = _data["Abteilung"];
      this.planstellenlangbezeichnung = _data["Planstellenlangbezeichnung"];
      this.sachbearbeiterPersonal = _data["SachbearbeiterPersonal"];
      this.sachbearbeiterZeiterfassung = _data["SachbearbeiterZeiterfassung"];
      this.sachbearbeiterAbrechnung = _data["SachbearbeiterAbrechnung"];
      this.firmenbezeichnung = _data["Firmenbezeichnung"];
      this.firmenkurzbezeichnung = _data["Firmenkurzbezeichnung"];
      this.buchungskreis = _data["Buchungskreis"];
      this.beschaeftigungsstatus = _data["Beschaeftigungsstatus"];
      this.kostenstellenartBezeichnung = _data["KostenstellenartBezeichnung"];
      this.telearbeit = _data["Telearbeit"];
      this.wochenstunden = _data["Wochenstunden"];
      this.fahrzeugart = _data["Fahrzeugart"];
      this.fahrzeugartBezeichnung = _data["FahrzeugartBezeichnung"];
      this.systemId = _data["SystemId"];
      this.mandant = _data["Mandant"];
    }
  }

  static fromJS(data: any): UserPrivateAddress {
    data = typeof data === "object" ? data : {};
    let result = new UserPrivateAddress();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["PrivateStraße"] = this.privateStraße;
    data["PrivatePostleitzahl"] = this.privatePostleitzahl;
    data["PrivateOrt"] = this.privateOrt;
    data["Dienststelle"] = this.dienststelle;
    data["Personalnummer"] = this.personalnummer;
    data["Titel"] = this.titel;
    data["Nachname"] = this.nachname;
    data["Vorname"] = this.vorname;
    data["Anrede"] = this.anrede;
    data["Geschlecht"] = this.geschlecht;
    data["Eintritt"] = this.eintritt ? this.eintritt.toISOString() : <any>undefined;
    data["Austritt"] = this.austritt ? this.austritt.toISOString() : <any>undefined;
    data["Diktatzeichen"] = this.diktatzeichen;
    data["Arbeitsplatz_Ort"] = this.arbeitsplatz_Ort;
    data["Arbeitsplatz_Strasse"] = this.arbeitsplatz_Strasse;
    data["Arbeitsplatz_Postleitzahl"] = this.arbeitsplatz_Postleitzahl;
    data["Arbeitsplatz_Raum"] = this.arbeitsplatz_Raum;
    data["Telefon"] = this.telefon;
    data["Fax"] = this.fax;
    data["Email"] = this.email;
    data["Handy"] = this.handy;
    data["Kartennummer"] = this.kartennummer;
    data["SipAdresse"] = this.sipAdresse;
    data["Geburtsdatum"] = this.geburtsdatum ? this.geburtsdatum.toISOString() : <any>undefined;
    data["AufbereiteterName"] = this.aufbereiteterName;
    data["Vorsatzwort"] = this.vorsatzwort;
    data["SAP_GueltigVon"] = this.sAP_GueltigVon ? this.sAP_GueltigVon.toISOString() : <any>undefined;
    data["SAP_GueltigBis"] = this.sAP_GueltigBis ? this.sAP_GueltigBis.toISOString() : <any>undefined;
    data["Mitarbeitergruppe"] = this.mitarbeitergruppe;
    data["Mitarbeiterkreis"] = this.mitarbeiterkreis;
    data["Kostenstelle"] = this.kostenstelle;
    data["Altersteilzeit_D_Vollzeit_GueltigVon"] = this.altersteilzeit_D_Vollzeit_GueltigVon ? this.altersteilzeit_D_Vollzeit_GueltigVon.toISOString() : <any>undefined;
    data["Altersteilzeit_D_Freistellung_GueltigVon"] = this.altersteilzeit_D_Freistellung_GueltigVon ? this.altersteilzeit_D_Freistellung_GueltigVon.toISOString() : <any>undefined;
    data["ZugeordneteOrgEinheiten"] = this.zugeordneteOrgEinheiten;
    if (Array.isArray(this.planstellenIds)) {
      data["PlanstellenIds"] = [];
      for (let item of this.planstellenIds) data["PlanstellenIds"].push(item);
    }
    data["PlanstellenIdsAsString"] = this.planstellenIdsAsString;
    data["Verknuepfungstext"] = this.verknuepfungstext;
    data["Abteilung"] = this.abteilung;
    data["Planstellenlangbezeichnung"] = this.planstellenlangbezeichnung;
    data["SachbearbeiterPersonal"] = this.sachbearbeiterPersonal;
    data["SachbearbeiterZeiterfassung"] = this.sachbearbeiterZeiterfassung;
    data["SachbearbeiterAbrechnung"] = this.sachbearbeiterAbrechnung;
    data["Firmenbezeichnung"] = this.firmenbezeichnung;
    data["Firmenkurzbezeichnung"] = this.firmenkurzbezeichnung;
    data["Buchungskreis"] = this.buchungskreis;
    data["Beschaeftigungsstatus"] = this.beschaeftigungsstatus;
    data["KostenstellenartBezeichnung"] = this.kostenstellenartBezeichnung;
    data["Telearbeit"] = this.telearbeit;
    data["Wochenstunden"] = this.wochenstunden;
    data["Fahrzeugart"] = this.fahrzeugart;
    data["FahrzeugartBezeichnung"] = this.fahrzeugartBezeichnung;
    data["SystemId"] = this.systemId;
    data["Mandant"] = this.mandant;
    return data;
  }
}

export interface IUserPrivateAddress {
  privateStraße?: string | undefined;
  privatePostleitzahl?: string | undefined;
  privateOrt?: string | undefined;
  dienststelle?: string | undefined;
  personalnummer?: string | undefined;
  titel?: string | undefined;
  nachname?: string | undefined;
  vorname?: string | undefined;
  anrede?: string | undefined;
  geschlecht?: string | undefined;
  eintritt?: Date;
  austritt?: Date;
  diktatzeichen?: string | undefined;
  arbeitsplatz_Ort?: string | undefined;
  arbeitsplatz_Strasse?: string | undefined;
  arbeitsplatz_Postleitzahl?: string | undefined;
  arbeitsplatz_Raum?: string | undefined;
  telefon?: string | undefined;
  fax?: string | undefined;
  email?: string | undefined;
  handy?: string | undefined;
  kartennummer?: string | undefined;
  sipAdresse?: string | undefined;
  geburtsdatum?: Date;
  aufbereiteterName?: string | undefined;
  vorsatzwort?: string | undefined;
  sAP_GueltigVon?: Date;
  sAP_GueltigBis?: Date;
  mitarbeitergruppe?: string | undefined;
  mitarbeiterkreis?: string | undefined;
  kostenstelle?: string | undefined;
  altersteilzeit_D_Vollzeit_GueltigVon?: Date;
  altersteilzeit_D_Freistellung_GueltigVon?: Date;
  zugeordneteOrgEinheiten?: string | undefined;
  planstellenIds?: string[] | undefined;
  planstellenIdsAsString?: string | undefined;
  verknuepfungstext?: string | undefined;
  abteilung?: string | undefined;
  planstellenlangbezeichnung?: string | undefined;
  sachbearbeiterPersonal?: string | undefined;
  sachbearbeiterZeiterfassung?: string | undefined;
  sachbearbeiterAbrechnung?: string | undefined;
  firmenbezeichnung?: string | undefined;
  firmenkurzbezeichnung?: string | undefined;
  buchungskreis?: string | undefined;
  beschaeftigungsstatus?: string | undefined;
  kostenstellenartBezeichnung?: string | undefined;
  telearbeit?: boolean;
  wochenstunden?: number;
  fahrzeugart?: string | undefined;
  fahrzeugartBezeichnung?: string | undefined;
  systemId?: string | undefined;
  mandant?: string | undefined;
}

export class UserWithSid implements IUserWithSid {
  loginName?: string | undefined;
  sid?: string | undefined;

  constructor(data?: IUserWithSid) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.loginName = _data["LoginName"];
      this.sid = _data["Sid"];
    }
  }

  static fromJS(data: any): UserWithSid {
    data = typeof data === "object" ? data : {};
    let result = new UserWithSid();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["LoginName"] = this.loginName;
    data["Sid"] = this.sid;
    return data;
  }
}

export interface IUserWithSid {
  loginName?: string | undefined;
  sid?: string | undefined;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}
